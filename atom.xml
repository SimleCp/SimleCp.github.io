<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zedxpp-blog</title>
  <subtitle>蜗牛, 为梦想而生。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zedxpp.com/"/>
  <updated>2018-07-23T09:07:26.000Z</updated>
  <id>http://zedxpp.com/</id>
  
  <author>
    <name>zedxpp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正确的使用pod install 和 pod update - CocoaPods</title>
    <link href="http://zedxpp.com/2018/07/23/%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8pod%20install%20%E5%92%8C%20pod%20update%20-%20CocoaPods/"/>
    <id>http://zedxpp.com/2018/07/23/正确的使用pod install 和 pod update - CocoaPods/</id>
    <published>2018-07-23T09:05:39.000Z</published>
    <updated>2018-07-23T09:07:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pod-install"><a href="#pod-install" class="headerlink" title="pod install"></a>pod install</h2><ol>
<li>在项目中第一次使用CocoaPods, 进行安装的时候使用这个命令.</li>
<li>在<code>Podfile</code>中<code>增加</code>或<code>删除</code>某个pod后, 也是使用这个命令. 而不是<code>pod update</code>.</li>
</ol>
<ul>
<li>每次运行<code>pod install</code>命令, 下载并安装新的pod时, 它会为<code>Podfile.lock</code>文件中的每个pod写入已安装的版本. 此文件跟踪每个pod的已安装版本并锁定这些版本(.lock命名因此而来).</li>
<li>当运行<code>pod install</code>，它只解析<code>Podfile.lock</code>中尚未列在其中的pod的依赖库.<ul>
<li>对于已经在<code>Podfile.lock</code>中列出的pod, <code>Podfile.lock</code>不会尝试检查是否有更新的版本.</li>
<li>对于尚未在<code>Podfile.lock</code>中列出的pod, 会搜索与<code>Podfile</code>（如中所述pod ‘MyPod’, ‘~&gt;1.2’）匹配的版本或最新的版本.</li>
</ul>
</li>
</ul>
<p>注: 第一次运行<code>pod install</code>的时候, <code>.xcworkspace项目</code>和<code>Pods目录</code>还不存在, <code>pod install</code>命令也会创建<code>.xcworkspace</code>和<code>Pods目录</code>, 但这是<code>pod install</code>命令的<code>顺带作用</code>，而不是它的<code>主要作用</code>.</p>
<h2 id="pod-outdated"><a href="#pod-outdated" class="headerlink" title="pod outdated"></a>pod outdated</h2><p>当运行<code>pod outdated</code>时, CocoaPods将列出所有比<code>Podfile.lock</code>（每个pod当前安装的版本）中, 已经列出的版本更新的pod版本. 这意味着如果你在这些pod上运行<code>pod update PODNAME</code>, 它将会把指定的pod更新到最新版本.</p>
<h2 id="pod-update"><a href="#pod-update" class="headerlink" title="pod update"></a>pod update</h2><p>当运行<code>pod update PODNAME</code>时, CocoaPods将尝试查找<code>PODNAME</code>更新的pod版本, 会忽略掉<code>Podfile.lock</code>中已经存在的版本.</p>
<p>如果直接运行<code>pod update</code>, 没有指定<code>PODNAME</code>, CocoaPods会把Podfile中所有的pod都更新到最新版本.(如果已经是最新版本了, 则不更新)</p>
<h2 id="预期用途"><a href="#预期用途" class="headerlink" title="预期用途"></a>预期用途</h2><p>使用<code>pod update PODNAME</code>, 将只能更新特定的pod(检查是否存在新版本并相应地更新pod). 相反, pod install不会尝试更新已安装的pod的版本.</p>
<p>当向Podfile中添加一个pod时, 应该运行<code>pod install</code>, 而不是用<code>pod update</code>来安装这个新pod.</p>
<p>只有在想要更新特定pod（或所有的pod）的版本时才会使用<code>pod update</code>.</p>
<h2 id="必须提交的Podfile-lock"><a href="#必须提交的Podfile-lock" class="headerlink" title="必须提交的Podfile.lock"></a>必须提交的Podfile.lock</h2><p>有时候可能你不想提交Pods目录到源代码管理中. 但是在多人开发的情况下, 一定要提交<code>Podfile.lock</code>这个文件, 因为这个文件里面记录了你的Podfile中所有pod的版本信息. 为避免你的Podfile中的pod版本和别人的Podfile中的pod发生版本不一样的情况, 而导致出现函数找不到或者其他的错误.</p>
<h2 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h2><ol>
<li>user1创建了项目</li>
</ol>
<p>user1创建了一个项目, 并且想用<code>A</code>, <code>B</code>, <code>C</code>这3个pod库, 这个时候用<code>pod install</code>安装了这些pod库, 并且假设这3个库的版本号都是<code>1.0.0</code>, 这些版本号等信息会记录在<code>Podfile.lock</code>文件中.</p>
<ol>
<li>user1添加了新的pod</li>
</ol>
<p>根据项目的进度需求, 添加了<code>D</code>这个pod库到项目中, 这个时候应该使用<code>pod install</code>去安装<code>D</code>这个库到项目中, 即使在添加<code>D</code>这个库之前, <code>B</code>的版本被维护者更新到了<code>1.1.0</code>, 使用<code>pod install</code>也只会安装<code>D</code>这个库到项目中, 而不会去帮你更新<code>B</code>的版本. 从而不会出现因为<code>B</code>的版本更新后, 假如某些函数过期了, 或者某些函数被移除了, 而导致你被迫需要修改项目代码.</p>
<ol>
<li>user2加入到项目中</li>
</ol>
<p>假设团队中新增加了一位基友user2, 他克隆了项目, 并且<code>pod install</code>. (前提是你没有把<code>Pods目录</code>添加到源代码管理中), 如果你将<code>Podfile.lock</code>提交到了版本控制. 那么基友安装后的pod会和你的一模一样, 不会出现他的pod版本比你的高. 即便现在<code>C</code>的版本更新到了<code>1.2.0</code>, 基友安装的也是<code>1.0.0</code>版本. 因为在<code>Podfile.lock</code>中记录的pod <code>C</code>就是<code>1.0.0</code>版本.</p>
<ol>
<li>检查pod的新版本</li>
</ol>
<p>后来, user1想要检查下是否有更新pod的版本. 运行<code>pod outdated</code>, 会告诉你pod <code>B</code>有一个新<code>1.1.0</code>版本, pod <code>C</code>已经是<code>1.2.0</code>版本. user1决定他想要更新pod <code>B</code>, 但不更新pod <code>C</code>. 因此, 他会运行<code>pod update B</code>, 将<code>B</code>从<code>1.0.0</code>版本更新到版本<code>1.1.0</code>（并相应的更新<code>Podfile.lock</code>）, 但会将pod <code>C</code>保留在版本中<code>1.0.0</code>(不会将其更新为<code>1.2.0</code>).</p>
<h2 id="使用指定版本的Podfile是不够的"><a href="#使用指定版本的Podfile是不够的" class="headerlink" title="使用指定版本的Podfile是不够的"></a>使用指定版本的Podfile是不够的</h2><p>有些人可能会认为, 通过在<code>Podfile</code>中指定pod确切的版本, 像<code>pod &#39;A&#39;, &#39;1.0.0&#39;</code>, 就足以保证每一个人和其他人都会有相同的版本. 然后他们甚至可以使用<code>pod update</code>, 即使只是添加一个新的pod, 认为它永远不会有更新其他pod版本的风险, 因为它们在Podfile中被固定到了一个特定的版本.</p>
<p>但事实上, 这还不足以保证我们上面场景中的user1和user2, 始终获得所有pod的完全相同的版本. 举一个典型的例子, 如果pod <code>A</code>中有对pod <code>A2</code>的依赖, 在<code>A.podspecas</code>中声明<code>dependency &#39;A2&#39;, &#39;~&gt; 3.0&#39;</code>. 在这种情况下，<code>pod &#39;A&#39;, &#39;1.0.0&#39;</code>在你的Podfile中使用的时候, 确实会强制user1和user2始终使用<code>A 1.0.0 的pod版本</code>.</p>
<p>但是: user1最终可能获取到的<code>A2版本是pod 3.4</code>(因为那时A2是最新版本), 当user2在以后加入项目时运行<code>pod install</code>, 他可能会在A2的版本中获得pod <code>3.5</code>(因为维护者A2可能在此期间发布了新版本).</p>
<p>这就是为什么为了确保在每个团队成员使用的每台电脑上, 所有相同的pod版本的唯一方法, 是使用<code>Podfile.lock</code>和正确使用<code>pod install</code>和<code>pod update</code>的原因.</p>
<h2 id="我应该将Pods目录添加到源代码管理中吗？"><a href="#我应该将Pods目录添加到源代码管理中吗？" class="headerlink" title="我应该将Pods目录添加到源代码管理中吗？"></a>我应该将Pods目录添加到源代码管理中吗？</h2><p>是否将Pods文件夹添加到源代码管理中都取决于你，因为工作流程因项目而异. 我们建议您将Pods目录保留在源代码管理下, 不要将其添加到您的.gitignore. 但最终这个决定取决于你:</p>
<h3 id="添加Pod目录的好处"><a href="#添加Pod目录的好处" class="headerlink" title="添加Pod目录的好处"></a>添加Pod目录的好处</h3><ul>
<li>克隆了repo后, 即使没有在机器上安装CocoaPods, 项目也可以立即构建和运行. 无需运行pod install, 也无需Internet连接.</li>
<li>Pod（代码/库）总是可用的, 即使Pod的源（例如GitHub）要关闭也是如此.</li>
<li>在克隆repo后, Pod组件保证与原始安装中的组件相同.</li>
</ul>
<h3 id="忽略Pods目录的好处"><a href="#忽略Pods目录的好处" class="headerlink" title="忽略Pods目录的好处"></a>忽略Pods目录的好处</h3><ul>
<li>源代码仓库将更小, 并且占用更少的空间.</li>
<li>只要所有Pod的源（例如GitHub）都可用, CocoaPods通常能够重新创建相同的安装.（从技术上讲, 无法保证pod install在Podfile中不使用提交SHA时, 运行将获取并重新创建相同的组件. 在Podfile中使用zip文件时尤其如此.）</li>
<li>执行源控制操作时不会有任何冲突, 例如合并具有不同Pod版本的分支.</li>
</ul>
<p>无论你是否在忽略Pods目录, Podfile并Podfile.lock应始终版本控制下保持.</p>
<p>本文内容来源:<br><a href="https://guides.cocoapods.org/using/pod-install-vs-update.html" target="_blank" rel="external">https://guides.cocoapods.org/using/pod-install-vs-update.html</a><br><a href="https://guides.cocoapods.org/using/using-cocoapods.html" target="_blank" rel="external">https://guides.cocoapods.org/using/using-cocoapods.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;pod-install&quot;&gt;&lt;a href=&quot;#pod-install&quot; class=&quot;headerlink&quot; title=&quot;pod install&quot;&gt;&lt;/a&gt;pod install&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在项目中第一次使用CocoaPods, 进行安装的时候使
    
    </summary>
    
      <category term="CocoaPods" scheme="http://zedxpp.com/categories/CocoaPods/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift Perfect服务端的自动化部署</title>
    <link href="http://zedxpp.com/2017/12/01/Swift%20Perfect%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <id>http://zedxpp.com/2017/12/01/Swift Perfect服务端的自动化部署/</id>
    <published>2017-12-01T12:47:11.000Z</published>
    <updated>2018-01-10T07:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>最开始学习Perfect框架的时候, 就思考过如何部署.后来也试过不少方式, 在今天一个比较特殊的情况下, 找到了一个我觉得目前最完美的部署方式.当然, 如果你用的是Perfect官方支持的阿里云, 亚马逊, 谷歌云这三种, 那么请直接前往这个地址就可以了. <a href="http://perfect.org/zh/assistant/" target="_blank" rel="external">http://perfect.org/zh/assistant/</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/719570-670732488be45bea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="如果你和我一样-用的是普通的vps-那么-请继续往下看-贫穷使我触发无限可能"><a href="#如果你和我一样-用的是普通的vps-那么-请继续往下看-贫穷使我触发无限可能" class="headerlink" title="如果你和我一样, 用的是普通的vps, 那么, 请继续往下看.(贫穷使我触发无限可能 -. -)"></a>如果你和我一样, 用的是普通的vps, 那么, 请继续往下看.(贫穷使我触发无限可能 -. -)</h4><h6 id="也许我的部署方式并不是最完美的-如果你有更好的方式-可以在下面评论告诉我-不甚感激"><a href="#也许我的部署方式并不是最完美的-如果你有更好的方式-可以在下面评论告诉我-不甚感激" class="headerlink" title="也许我的部署方式并不是最完美的, 如果你有更好的方式, 可以在下面评论告诉我.不甚感激."></a>也许我的部署方式并不是最完美的, 如果你有更好的方式, 可以在下面评论告诉我.不甚感激.</h6><p>曾经尝试过的部署方式思路, 有几种.</p>
<p>1.通过在服务器用git的钩子进行部署, 在服务器上, 会有两个用户, 一个root用户,<br> 一个git用户, 但是如果不用root权限的话, git权限的用户找不到编译环境, 如果强行把编译环境修改到git权限的用户,那么root用户又无法编译了. 自动编译不能用, 所以只能手动编译和启动. 在无法找到更完美的部署方式前, 一直用的这个.<br>我目前的操作步骤, 在服务器上创建一个git文件夹, 然后通过钩子, 监听到push后, 打包该文件, 拷贝到一个编译目录, (直接在原来的目录上进行编译, 也是可以的), 然后解压, 解压后手动通过ssh进行编译和启动.</p>
<p>2.通过官方支持的docker进行部署, 但是在本地docker环境里面进行编译的时候, 始终无法完成编译, 说缺少openssl的一个头文件,但是在本地编译是正常的.在两台系统版本号不同的电脑上, 都尝试过, 结果一样, 所以不知道是哪里错了…很无奈…</p>
<p>3.这一种方式, 也是目前我个人发现的最完美的方式了.</p>
<p>不多BB, 看思路图.</p>
<p><img src="https://upload-images.jianshu.io/upload_images/719570-13cde93f99f75b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="所用到的环境以及工具"><a href="#所用到的环境以及工具" class="headerlink" title="所用到的环境以及工具"></a>所用到的环境以及工具</h3><h4 id="1-宝塔面板"><a href="#1-宝塔面板" class="headerlink" title="1 宝塔面板"></a>1 宝塔面板</h4><p>让服务器ssh界面化, 也是自动化部署的关键, 你可以采取其他的监听webhook的方式, 也可以达到同样目的</p>
<p>在使用面板的时候, 设置好代码的端口后(比如8080), 记得在这个里面对你的端口进行放行, 否则无法访问.</p>
<p><img src="https://upload-images.jianshu.io/upload_images/719570-722e51e54ce1c17c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="2-阿里云代码托管"><a href="#2-阿里云代码托管" class="headerlink" title="2 阿里云代码托管"></a>2 阿里云代码托管</h4><h4 id="3-Ubuntu服务器"><a href="#3-Ubuntu服务器" class="headerlink" title="3 Ubuntu服务器"></a>3 Ubuntu服务器</h4><h4 id="4-把Ubuntu服务器的公钥添加到阿里云代码托管平台"><a href="#4-把Ubuntu服务器的公钥添加到阿里云代码托管平台" class="headerlink" title="4 把Ubuntu服务器的公钥添加到阿里云代码托管平台"></a>4 把Ubuntu服务器的公钥添加到阿里云代码托管平台</h4><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>1.在代码托管平台创建代码仓库.</p>
<p>2.在服务器创建你存放Perfect代码的目录, 对代码平台的代码仓库进行git clone</p>
<p>3.在宝塔面板上安装webhook</p>
<p>注: 通过宝塔面板可以访问操作文件和文件夹, 并且面板自带了很多有用的工具, nginx, 数据库, 等.我觉得非常方便友好, 并且这个东西是免费的, 一键安装, 强烈建议使用. 具体有哪些功能你可以去官网看, 反正点一下又不会怀孕不是. <a href="http://bt.cn" target="_blank" rel="external">http://bt.cn</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/719570-af3b17e737c6052a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>4.安装完后添加Hook.名称随便写.</p>
<p><img src="https://upload-images.jianshu.io/upload_images/719570-92fe7c8947357b9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>脚本内容如下(你也可以根据你自己的情况进行精简), 导入编译环境的教程地址 <a href="http://www.jianshu.com/p/538b685b6a62" target="_blank" rel="external">http://www.jianshu.com/p/538b685b6a62</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/719570-ef67d127cd269fb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>5.把添加后的面板请求地址和密匙添加到代码仓库的webhooks(我是用push事件来做的.你也可以用其他方式.比如tag)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/719570-2e2cf3dd71cf55b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/719570-d2d008be2391998b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>6.添加成功后, 就会像这样</p>
<p><img src="https://upload-images.jianshu.io/upload_images/719570-06cf2c13deda9e84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>7.都设置成功后, 你可以在你的面板上测试面板的webhook操作是否正确, 阿里云代码托管平台也可以测试发起请求的操作是否正确. <code>TEST HOOK</code></p>
<p>8.在本地拉取阿里云代码仓库的代码, 进行代码提交, 触发以上一系列的webhook.</p>
<h5 id="以下是成果图"><a href="#以下是成果图" class="headerlink" title="以下是成果图"></a>以下是成果图</h5><p><img src="https://upload-images.jianshu.io/upload_images/719570-9386808bec4b9be8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/719570-70a71fda561c3dcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/719570-7f3d8d6849c1576a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>简洁思路: 如果你设置的是push事件, 当阿里云代码托管收到你的代码push后, 会去请求服务器的webhook, 服务器的webhook收到请求后, 会在服务器进行1进入代码目录, 2拉取阿里云的代码, 3编译并且启动的操作.感受自动化部署的愉悦吧!</p>
<h3 id="如果你觉得文章帮助了你-关注我不迷路-后面还会分享Perfect的更多姿势"><a href="#如果你觉得文章帮助了你-关注我不迷路-后面还会分享Perfect的更多姿势" class="headerlink" title="如果你觉得文章帮助了你, 关注我不迷路, 后面还会分享Perfect的更多姿势."></a>如果你觉得文章帮助了你, 关注我不迷路, 后面还会分享Perfect的更多姿势.</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最开始学习Perfect框架的时候, 就思考过如何部署.后来也试过不少方式, 在今天一个比较特殊的情况下, 找到了一个我觉得目前最完美的部署方式.当然, 如果你用的是Perfect官方支持的阿里云, 亚马逊, 谷歌云这三种, 那么请直接前往这个地址就可以了. &lt;a href
    
    </summary>
    
      <category term="Swift-Perfect" scheme="http://zedxpp.com/categories/Swift-Perfect/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Supervisor让你的Swift服务器项目后台运行</title>
    <link href="http://zedxpp.com/2017/10/07/%E4%BD%BF%E7%94%A8Supervisor%E8%AE%A9%E4%BD%A0%E7%9A%84Swift%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/"/>
    <id>http://zedxpp.com/2017/10/07/使用Supervisor让你的Swift服务器项目后台运行/</id>
    <published>2017-10-07T11:46:57.000Z</published>
    <updated>2017-10-07T12:05:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>当你按<code>control + c</code>退出vps上的swift项目运行的时候, 其实你的项目已经停止了, 用服务器ip+端口号访问, 已经无法响应了.</p>
<p>这个时候就需要用<code>supervisor</code>来让项目一直在后台运行, 这样, 你编写的api才能一直能访问.</p>
<h2 id="基本配置和说明"><a href="#基本配置和说明" class="headerlink" title="基本配置和说明"></a>基本配置和说明</h2><p>打开终端连接上服务器.创建找一个文件夹存放你的脚本.我存放在<code>Code</code>文件夹, 并且创建了一个文件, 名字叫<code>script.sh</code>的文件.</p>
<p><code>/root/Code/script.sh</code>, 也就是你需要supervisor帮你执行这个脚本.并且一直后台运行.</p>
<p><code>/root/Code</code>的<code>script.sh</code>里面, 编写着路径地址和执行命令.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /root/Code/PerfectTemplate</div><div class="line">.build/debug/PerfectTemplate</div></pre></td></tr></table></figure>
<h2 id="安装并配置"><a href="#安装并配置" class="headerlink" title="安装并配置"></a>安装并配置</h2><p>输入<code>sudo apt-get install supervisor</code>安装supervisor.</p>
<p>安装完成后, 进入<code>cd /etc/supervisor/conf.d</code>, 创建并编辑 <code>vim swiftServer.conf</code>, <code>swiftServer</code>是我的文件名和program名, 你也可以用你喜欢的.</p>
<p>在文件中粘贴以下代码, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[program:swiftServer] // swiftServer 刚刚取的program名</div><div class="line"></div><div class="line">command=sh script.sh // 执行的脚本名称</div><div class="line"></div><div class="line">process_name=%(program_name)s</div><div class="line"></div><div class="line">directory=/root/Code // 执行的脚本路径</div><div class="line"></div><div class="line">autorestart=true</div><div class="line"></div><div class="line">user=root // 用户名</div></pre></td></tr></table></figure>
<p><code>更多的supervisor配置信息请自行查阅, 这里只保证项目能正常启动起来.</code></p>
<p>输入<code>supervisorctl reload</code>让你刚刚的配置生效.</p>
<p>输入<code>supervisorctl start swiftServer</code>启动并后台运行</p>
<p>再次在网页中打开<code>服务器ip:8181</code>, <code>Hello, world!</code>时刻与你同在.  ^.^</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;当你按&lt;code&gt;control + c&lt;/code&gt;退出vps上的swift项目运行的时候, 其实你的项目已经停止了, 用服务器ip+端口
    
    </summary>
    
      <category term="Swift-Perfect" scheme="http://zedxpp.com/categories/Swift-Perfect/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift Perfect Mac本地环境配置</title>
    <link href="http://zedxpp.com/2017/10/07/Swift%20Perfect%20Mac%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://zedxpp.com/2017/10/07/Swift Perfect Mac本地环境配置/</id>
    <published>2017-10-07T11:46:57.000Z</published>
    <updated>2018-01-10T07:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Perfect框架中文文档地址: <a href="http://perfect.org/docs/index_zh_CN.html" target="_blank" rel="external">http://perfect.org/docs/index_zh_CN.html</a></p>
<h2 id="开启本地服务器"><a href="#开启本地服务器" class="headerlink" title="开启本地服务器"></a>开启本地服务器</h2><p>首先, 根据Perfect框架的官网文档, 快速开启本地服务器 <a href="http://perfect.org/docs/gettingStarted_zh_CN.html" target="_blank" rel="external">http://perfect.org/docs/gettingStarted_zh_CN.html</a></p>
<h2 id="数据库选择"><a href="#数据库选择" class="headerlink" title="数据库选择"></a>数据库选择</h2><p>后端开发, 必不可少的便是数据库, Perfect框架支持好几种数据库, 我自己选用的是MySql数据库, 以下所有教程都是基于MySql数据库进行展开的.</p>
<p><img src="/images/Perfect/15073473949127.jpg" alt=""></p>
<p><code>教程所有内容主要是以在本地和服务器部署各种环境为主, 避免浪费不必要的时间在部署环境上.</code></p>
<h2 id="在Mac上安装MySql"><a href="#在Mac上安装MySql" class="headerlink" title="在Mac上安装MySql"></a>在Mac上安装MySql</h2><p>打开终端, 安装mysql(请勿使用dmg的方式安装mysql, 经我测试, 发现会碰到一些麻烦的问题)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install mysql</div></pre></td></tr></table></figure>
<ul>
<li>在Mac OS 10.12 上面, 直接安装即可.</li>
<li>在Mac OS 10.13 上面, 可能需要更新Homebrew, 更新Homebrew又需要Ruby, 更新Ruby又需要Rvm等等. 在这个版本的操作系统上面, Homebrew拿不到/usr/local文件夹的读写权限, 按照官方给出的解决方法(<a href="https://github.com/Homebrew/brew/issues/3228" target="_blank" rel="external">https://github.com/Homebrew/brew/issues/3228</a>), 在我自己的mac电脑上并不行, 来回折腾了1个多小时还是不行, 我决定采取暴力方法.直接卸载重装Homebrew, 重新安装后, 顺利的在mac上安装好了mysql.</li>
</ul>
<p><code>如果你也需要采用这种暴力方法, 请继续看, 如果你已经顺利安装了, 直接跳过卸载重装的部分.</code></p>
<h3 id="卸载Homebrew"><a href="#卸载Homebrew" class="headerlink" title="卸载Homebrew"></a>卸载Homebrew</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> `brew --prefix` </div><div class="line">$ rm -rf Cellar$ brew prune </div><div class="line">$ rm -rf Library .git .gitignore bin/brew README.md share/man/man1/brew </div><div class="line">$ rm -rf ~/Library/Caches/Homebrew</div></pre></td></tr></table></figure>
<ul>
<li><a href="http://www.jianshu.com/p/18772092ee6b" target="_blank" rel="external">参考来自</a></li>
</ul>
<h3 id="重新安装Homebrew"><a href="#重新安装Homebrew" class="headerlink" title="重新安装Homebrew"></a>重新安装Homebrew</h3><p>进入Homebrew官网 <a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">https://brew.sh/index_zh-cn.html</a>, 复制这里的命令到终端安装即可(安装命令可能会变, 所以请自行前往复制)</p>
<p><img src="/images/Perfect/15073483710624.jpg" alt=""></p>
<h2 id="MySql启动与配置"><a href="#MySql启动与配置" class="headerlink" title="MySql启动与配置"></a>MySql启动与配置</h2><p>安装完成后, 手动启动mysql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql.server start    # 启动</div><div class="line">mysql.server stop     # 停止</div><div class="line">mysql.server restart  # 重启</div></pre></td></tr></table></figure>
<p>打开数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u root -p</div></pre></td></tr></table></figure>
<p>设置mysql密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UPDATE user SET authentication_string=PASSWORD(&apos;newpassword&apos;) where USER=&apos;root&apos;;</div></pre></td></tr></table></figure>
<p><code>更新用户名和密码, 用户名建议用root, 后面的教程都会以此为例子.</code></p>
<p>设置完密码后刷新权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FLUSH PRIVILEGES</div></pre></td></tr></table></figure>
<p>输入 <code>\q</code> 退出数据库</p>
<p>重新登录数据库, 尝试用新密码进入, 如果成功, 退出数据库, 进行接下来的步骤.</p>
<p><code>建议在网上找一个数据库软件, 更加直观的查看数据和调试.</code></p>
<h3 id="代码连接数据库"><a href="#代码连接数据库" class="headerlink" title="代码连接数据库"></a>代码连接数据库</h3><p>接下来回到本地服务器项目代码这边.</p>
<p>打开<code>Package.swift</code>导入<code>.Package(url:&quot;https://github.com/PerfectlySoft/Perfect-MySQL.git&quot;, majorVersion: 3),</code> 注意最后面有个逗号.</p>
<p>在终端执行<code>swift build</code>和<code>swift package generate-xcodeproj</code>, 用xcode打开项目.打开<code>main.swift</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import PerfectMySQL // 导入</div><div class="line"></div><div class="line">// 配置数据库信息</div><div class="line">let testHost = &quot;127.0.0.1&quot;</div><div class="line">let testUser = &quot;root&quot;</div><div class="line">let testPassword = &quot;数据库密码&quot;</div><div class="line">let testDB = &quot;mysql&quot;</div></pre></td></tr></table></figure>
<p><code>除了密码需要改成你自己设置的密码, 其他的照搬</code></p>
<p>加入以下函数并调用, 在这个函数声明之后, 随处调用即可</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> mysql = <span class="type">MySQL</span>() <span class="comment">// 创建一个MySQL连接实例</span></div><div class="line">    <span class="keyword">let</span> connected = mysql.connect(host: testHost, user: testUser, password: testPassword)</div><div class="line">    <span class="keyword">guard</span> connected <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 验证一下连接是否成功</span></div><div class="line">        <span class="built_in">print</span>(mysql.errorMessage())</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(mysql.listDatabases()</span>)"</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">defer</span> &#123;</div><div class="line">        mysql.close() <span class="comment">//这个延后操作能够保证在程序结束时无论什么结果都会自动关闭数据库连接</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行项目, 控制台打印</p>
<pre><code>[&quot;information_schema&quot;, &quot;mysql&quot;, &quot;performance_schema&quot;, &quot;sys&quot;]
</code></pre><p>表示数据库已经用代码连接成功.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Perfect框架中文文档地址: &lt;a href=&quot;http://perfect.org/docs/index_zh_CN.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://perfect.org/docs/index_zh_CN.ht
    
    </summary>
    
      <category term="Swift-Perfect" scheme="http://zedxpp.com/categories/Swift-Perfect/"/>
    
    
  </entry>
  
  <entry>
    <title>开启你的Swift服务器之旅-Perfect框架</title>
    <link href="http://zedxpp.com/2017/10/07/%E5%BC%80%E5%90%AF%E4%BD%A0%E7%9A%84Swift%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E6%97%85-Perfect%E6%A1%86%E6%9E%B6/"/>
    <id>http://zedxpp.com/2017/10/07/开启你的Swift服务器之旅-Perfect框架/</id>
    <published>2017-10-07T11:46:57.000Z</published>
    <updated>2018-01-21T02:43:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想学习一门后端语言, 能够写一些Api给自己的App使用. 考虑过js配合node.js, 后来放弃了. </p>
<p>最开始看到swift相关的新闻, 已经知道swift能够编写服务器, 但是一直没有怎么关注, 直到那天我简单看了一下swift的几个服务器框架, 才发现今日的swift服务器框架, 早已足够满足我的现有需求了.</p>
<p>为什么要选择Perfect这个框架, 是因为他星星最多, 中英文文档. 非常友好.</p>
<p><a href="https://github.com/perfectlySoft/Perfect" target="_blank" rel="external">https://github.com/perfectlySoft/Perfect</a></p>
<p><a href="https://github.com/vapor/Vapor" target="_blank" rel="external">https://github.com/vapor/Vapor</a></p>
<p><a href="https://github.com/ibm-swift/kitura" target="_blank" rel="external">https://github.com/ibm-swift/kitura</a></p>
<p><a href="https://github.com/zewo/Zewo" target="_blank" rel="external">https://github.com/zewo/Zewo</a></p>
<h2 id="看完系列文章-你能收获什么"><a href="#看完系列文章-你能收获什么" class="headerlink" title="看完系列文章, 你能收获什么?"></a>看完系列文章, 你能收获什么?</h2><ol>
<li><a href="http://zedxpp.com/2017/10/07/Swift%20Perfect%20Mac%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">Perfect在Mac本地环境的配置</a></li>
<li><a href="http://zedxpp.com/2017/10/07/%E5%9C%A8Ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AESwift%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/">在Ubuntu服务器上配置Swift编译环境</a></li>
<li><a href="http://zedxpp.com/2017/10/07/%E5%9C%A8Ubuntu%E5%AE%89%E8%A3%85MySql/">在Ubuntu服务器上安装MySql</a></li>
<li><a href="http://zedxpp.com/2017/10/07/%E4%BD%BF%E7%94%A8Supervisor%E8%AE%A9%E4%BD%A0%E7%9A%84Swift%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/">使用Supervisor让你的Swift服务器项目后台运行</a></li>
<li><a href="http://zedxpp.com/2017/12/01/Swift%20Perfect%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/">Swift Perfect服务端的自动化部署</a></li>
</ol>
<p>当你掌握了以上的姿势后, 你就可以给自己编写接口了, 是不是很赤鸡?</p>
<p>其实Perfect有自己的部署工具<a href="https://perfect.org/zh/assistant/" target="_blank" rel="external">https://perfect.org/zh/assistant/</a>, 但是仅限于<code>亚马逊云EC2服务器部署</code>和<code>Google App Engine 谷歌应用引擎部署</code>, 鉴于自己买<code>非以上两种的vps</code>比较便宜, 而且自己写点接口, 不需要这么贵.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一直想学习一门后端语言, 能够写一些Api给自己的App使用. 考虑过js配合node.js, 后来放弃了. &lt;/p&gt;
&lt;p&gt;最开始看到sw
    
    </summary>
    
      <category term="Swift-Perfect" scheme="http://zedxpp.com/categories/Swift-Perfect/"/>
    
    
  </entry>
  
  <entry>
    <title>在Ubuntu安装MySql</title>
    <link href="http://zedxpp.com/2017/10/07/%E5%9C%A8Ubuntu%E5%AE%89%E8%A3%85MySql/"/>
    <id>http://zedxpp.com/2017/10/07/在Ubuntu安装MySql/</id>
    <published>2017-10-07T11:46:57.000Z</published>
    <updated>2018-01-10T08:08:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h2><p>打开终端, 链接服务器, 输入<code>sudo apt-get install mysql-server mysql-client</code>安装MySql数据库. 安装过程中会叫你输入两次密码, </p>
<p><img src="/images/Perfect/QQ20171007-102429.png" alt="QQ20171007-102429"><br><img src="/images/Perfect/QQ20171007-102447.png" alt="QQ20171007-102447"></p>
<p>安装完成后, 输入<code>mysql -u root -p</code>, 输入刚刚的密码, 进入数据库.</p>
<p><img src="/images/Perfect/QQ20171007-102903.png" alt="QQ20171007-102903"></p>
<h2 id="配置数据库的远程访问"><a href="#配置数据库的远程访问" class="headerlink" title="配置数据库的远程访问"></a>配置数据库的远程访问</h2><p>有时候需要远程管理服务器上的数据库, 就要配置远程访问.</p>
<p>输入<code>\q</code>退出数据库.<code>cd /etc/mysql/mysql.conf.d/</code>进入文件夹, <code>vi mysqld.cnf</code>打开配置文件, 把<code>bind-address = 127.0.0.1</code>前面加个<code>#</code>给注释了.</p>
<p><img src="/images/Perfect/QQ20171007-104911.png" alt="QQ20171007-104911"></p>
<p>然后重新<code>mysql -u root -p</code>进入数据库, 执行<code>GRANT ALL PRIVILEGES ON *.* TO &#39;&lt;user&gt;&#39;@&#39;%&#39; IDENTIFIED BY &#39;&lt;password&gt;&#39; WITH GRANT OPTION;</code>, <code>&lt;user&gt;</code>换成你想设置的用户名, <code>&lt;password&gt;</code>换成密码, <code>&#39;&#39;不能少了</code>, 然后再执行<code>FLUSH PRIVILEGES</code>刷新权限. 最后重启一下数据库.</p>
<p>mac和ubuntu的数据库命令是不一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo service mysql start 开启</div><div class="line">sudo service mysql stop 停止</div><div class="line">sudo service mysql restart 重启</div></pre></td></tr></table></figure>
<p>打开电脑上的的数据库软件, 输入你的服务器ip地址, 端口号默认3306, 输入刚刚设置的用户名和密码.连接.</p>
<p>现在, 你已经用本地数据库软件成功连接服务器上的数据库了.</p>
<p><img src="/images/Perfect/QQ20171007-103629.png" alt="QQ20171007-103629"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装数据库&quot;&gt;&lt;a href=&quot;#安装数据库&quot; class=&quot;headerlink&quot; title=&quot;安装数据库&quot;&gt;&lt;/a&gt;安装数据库&lt;/h2&gt;&lt;p&gt;打开终端, 链接服务器, 输入&lt;code&gt;sudo apt-get install mysql-server mys
    
    </summary>
    
      <category term="Swift-Perfect" scheme="http://zedxpp.com/categories/Swift-Perfect/"/>
    
    
  </entry>
  
  <entry>
    <title>在Ubuntu服务器配置Swift编译环境</title>
    <link href="http://zedxpp.com/2017/10/07/%E5%9C%A8Ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AESwift%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://zedxpp.com/2017/10/07/在Ubuntu服务器配置Swift编译环境/</id>
    <published>2017-10-07T11:46:57.000Z</published>
    <updated>2018-01-10T08:03:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h2><p>购买vps, 安装Ubuntu, 请安装以下3种os中的任意一种. 我购买的vps上, 最新并且最兼容swift的是Ubuntu16.04 64位的.</p>
<ul>
<li>Ubuntu 14.04, 16.04 or 16.10 (64-bit)</li>
</ul>
<h2 id="配置Swift编译环境"><a href="#配置Swift编译环境" class="headerlink" title="配置Swift编译环境"></a>配置Swift编译环境</h2><h3 id="终端连接vps"><a href="#终端连接vps" class="headerlink" title="终端连接vps"></a>终端连接vps</h3><p>打开终端, 输入 <code>ssh root@vps的ip地址</code>, 输入vps的密码(vps自动生成的), 比如 <code>ssh root@133.84.12.61</code></p>
<p>第一次连接会出现一个输入yes和no的询问, 输入yes回车继续</p>
<p>当终端的开头变的和之前不一样的时候, 就是连接成功了, 比如我的, <code>root@swift:~#</code></p>
<p><img src="/images/Perfect/QQ20171007-094122.png" alt="QQ20171007-094122"></p>
<h3 id="配置必要环境"><a href="#配置必要环境" class="headerlink" title="配置必要环境"></a>配置必要环境</h3><p>输入以下命令安装必须的库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install openssl libssl-dev uuid-dev</div></pre></td></tr></table></figure>
<p>现在, 你已经用终端和vps连接成功了, 接下来创建两个文件夹, 分别存放你的swift代码和swift工具的编译环境</p>
<p>查看当前文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls 查看当前目录下的文件夹, 不显示隐藏文件</div><div class="line">ls -a 查看当前目录下的文件夹, 显示隐藏文件</div></pre></td></tr></table></figure>
<p>分别输入以下命令, 创建Code文件夹和Swift文件夹, 前者用来存放代码, 后者用来存放swift的编译环境(文件夹名字你可以自己取)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir Code</div><div class="line">mkdir Swift</div></pre></td></tr></table></figure>
<p>输入 <code>ls -a</code> 继续查看文件夹</p>
<p><img src="/images/Perfect/QQ20171007-094244.png" alt="QQ20171007-094244"></p>
<p><code>cd Swfit</code> 进入文件夹, 输入 <code>sudo apt-get install clang libicu-dev</code> 安装必要的工具, 出现问你是否继续的, 直接输入 <code>y</code> 继续</p>
<p><img src="/images/Perfect/QQ20171007-094907.png" alt="QQ20171007-094907"></p>
<p>安装完成</p>
<p><img src="/images/Perfect/QQ20171007-094921.png" alt="QQ20171007-094921"></p>
<h3 id="配置swift编译工具"><a href="#配置swift编译工具" class="headerlink" title="配置swift编译工具"></a>配置swift编译工具</h3><p>进入swift官方网站, 获取下载地址, <a href="https://swift.org/download/" target="_blank" rel="external">https://swift.org/download/</a></p>
<p>我选择的是Releases版本, Swift 4.0, Ubuntu 16.04版本, 版本和你的vps系统版本对应即可. 选中<code>Ubuntu 16.04</code>, 右键获取链接地址, <code>https://swift.org/builds/swift-4.0-release/ubuntu1604/swift-4.0-RELEASE/swift-4.0-RELEASE-ubuntu16.04.tar.gz</code> 记录下来.</p>
<p>在对应的<code>Ubuntu 16.04</code>下面, 选中<code>Signature</code>, 继续获取<code>Signature</code>的地址, 继续记录下来.</p>
<p><code>第一个获取的是swift编译环境的地址, 第二个获取的是对应编译环境的签名地址.</code></p>
<p>在终端中输入 <code>wget 刚刚获取的swift编译环境的地址</code></p>
<p><code>wget https://swift.org/builds/swift-4.0-release/ubuntu1604/swift-4.0-RELEASE/swift-4.0-RELEASE-ubuntu16.04.tar.gz</code></p>
<p><img src="/images/Perfect/QQ20171007-095254.png" alt="QQ20171007-095254"></p>
<p>在终端中输入 <code>wget 签名地址</code></p>
<p><img src="/images/Perfect/QQ20171007-095749.png" alt="QQ20171007-095749"></p>
<p>等文件都下载完成后, 继续输入, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gpg --keyserver hkp://pool.sks-keyservers.net \</div><div class="line">      --recv-keys \</div><div class="line">      &apos;7463 A81A 4B2E EA1B 551F  FBCF D441 C977 412B 37AD&apos; \</div><div class="line">      &apos;1BE1 E29A 084C B305 F397  D62A 9F59 7F4D 21A5 6D5F&apos; \</div><div class="line">      &apos;A3BA FD35 56A5 9079 C068  94BD 63BC 1CFE 91D3 06C6&apos; \</div><div class="line">      &apos;5E4D F843 FB06 5D7F 7E24  FBA2 EF54 30F0 71E1 B235&apos;</div></pre></td></tr></table></figure>
<p><img src="/images/Perfect/QQ20171007-095335.png" alt="QQ20171007-095335"></p>
<p>输入<code>ls</code>查看当前文件夹, 文件夹中有两个, 一个是swift编译工具的压缩包状态, 一个是签名文件.</p>
<p>从终端中复制签名文件的名字, <code>swift-4.0-RELEASE-ubuntu16.04.tar.gz.sig</code> 在前面加上 <code>gpg --verify</code>, 变成 <code>gpg --verify swift-4.0-RELEASE-ubuntu16.04.tar.gz.sig</code>, 进行验证, 出现和图上一样的, 表示没问题.</p>
<p><img src="/images/Perfect/QQ20171007-100114.png" alt="QQ20171007-100114"></p>
<p>输入 <code>tar xzf 包名</code>, 进行解压.</p>
<p><img src="/images/Perfect/QQ20171007-100400.png" alt="QQ20171007-100400"></p>
<p>再次输入<code>ls</code>, 会发现多了一个文件夹.</p>
<p>进入刚刚解压出来的文件夹里面, 再进入<code>usr</code>, 进入<code>bin</code>, 输入<code>pwd</code>, 获取全路径, 记录下来.</p>
<p><img src="/images/Perfect/QQ20171007-100516.png" alt="QQ20171007-100516"></p>
<p>输入<code>cd ~</code>进入根目录, 输入<code>ls -a</code>, 输入<code>vi .profile</code>打开文件</p>
<p><img src="/images/Perfect/QQ20171007-100913.png" alt="QQ20171007-100913"></p>
<p>在当前文件中加入<code>export PATH=刚刚获取的全路径:&quot;${PATH}&quot;</code>, 不要加到最后面一句命令的后面了. 否则就不能正常生效.把刚刚加入进去的那句命令复制(后面要用)</p>
<p><img src="/images/Perfect/QQ20171007-101022.png" alt="QQ20171007-101022"></p>
<p>退出并保存<code>.profile</code>文件, 粘贴刚刚赋值的命令, 执行.</p>
<p><img src="/images/Perfect/QQ20171007-101104.png" alt="QQ20171007-101104"></p>
<p>输入<code>swift --version</code>, 出现正确版本号, swift编译环境搭建完毕.</p>
<p><img src="/images/Perfect/QQ20171007-101220.png" alt="QQ20171007-101220"></p>
<h3 id="在vps上编译项目"><a href="#在vps上编译项目" class="headerlink" title="在vps上编译项目"></a>在vps上编译项目</h3><p>继续查看当前文件夹, 进入<code>Code</code>文件夹, 按照之前在本地快速搭建服务器的方法, 再克隆并运行一次.<br><code>swift build</code>的时候, 如果出现和图中一样的error, <code>error while loading shared libraries: libcurl.so.4: cannot open shared object file: No such file or directory</code>, 输入<code>sudo apt-get install libcurl3</code>, 安装<code>libcurl3</code>, 继续后续步骤, 编译成功后, 使用<code>服务器地址:8181</code>访问, 网页中出现<code>Hello, world!</code>, 也就美滋滋了~</p>
<p><img src="/images/Perfect/QQ20171007-101826.png" alt="QQ20171007-101826"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装Ubuntu&quot;&gt;&lt;a href=&quot;#安装Ubuntu&quot; class=&quot;headerlink&quot; title=&quot;安装Ubuntu&quot;&gt;&lt;/a&gt;安装Ubuntu&lt;/h2&gt;&lt;p&gt;购买vps, 安装Ubuntu, 请安装以下3种os中的任意一种. 我购买的vps上, 最新
    
    </summary>
    
      <category term="Swift-Perfect" scheme="http://zedxpp.com/categories/Swift-Perfect/"/>
    
    
  </entry>
  
  <entry>
    <title>为你的hexo博客配置个性域名</title>
    <link href="http://zedxpp.com/2017/03/05/%E4%B8%BA%E4%BD%A0%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%B8%AA%E6%80%A7%E5%9F%9F%E5%90%8D/"/>
    <id>http://zedxpp.com/2017/03/05/为你的hexo博客配置个性域名/</id>
    <published>2017-03-05T14:49:43.000Z</published>
    <updated>2018-01-10T07:55:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章以阿里云的.com域名为例子, 你也可以购买其他后缀的域名.</p>
<h2 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h2><p>1.打开阿里云<a href="https://wanwang.aliyun.com/" target="_blank" rel="external">https://wanwang.aliyun.com/</a>, 输入你想搜索的域名, 点击<code>查域名</code>.</p>
<p>2.选好域名, 域名的后缀, 加入清单, 确认信息, 然后去结算.</p>
<p><img src="/images/com/1.png" alt=""></p>
<p>3.确定域名, 年限, 持有者为个人, 创建信息模板. 立即购买.</p>
<p><img src="/images/com/2.png" alt=""></p>
<p><img src="/images/com/3.png" alt=""></p>
<p>4.结算完成后, 点击右上角的控制台, 为域名进行解析.</p>
<p><img src="/images/com/4.png" alt=""></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>1.点击域名, 域名列表, 找到域名进行解析.</p>
<p><img src="/images/com/5.png" alt=""></p>
<p>2.添加<code>3条</code>解析记录.初次解析可能会有点慢.</p>
<ul>
<li><p>记录类型, 主机记录, 记录值, 是需要我们填写的, 其他的不要管.</p>
</li>
<li><p>按我下面的指示填写, 除了<code>pengpengtest.github.io</code>中的<code>pengpengtest</code>需要换成你的<code>github用户名</code>, 其他的照着填.</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">记录类型 	主机记录 	记录值</div><div class="line">CNAME      www       你的github用户名.github.io</div><div class="line">A          @         192.30.252.153</div><div class="line">A          @         192.30.252.154</div></pre></td></tr></table></figure>
<p><img src="/images/com/6.png" alt=""></p>
<h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><p>1.先进入桌面, <code>cd 你的hexo本地目录</code>, <code>cd source</code>, <code>touch CNAME</code>创建CNAME文件, <code>open CNAME</code>打开并编辑.</p>
<p><img src="/images/com/7.png" alt=""></p>
<p>2.填入域名, 不用加任何<a href="http://或者www" target="_blank" rel="external">http://或者www</a>, 填写完成后保存退出.</p>
<p><img src="/images/com/8.png" alt=""></p>
<p>3.输入<code>../</code>回到你的hexo本地目录. <code>hexo g -d</code>重新生成部署.</p>
<p><img src="/images/com/9.png" alt=""></p>
<p>4.然后访问域名, 比如我的, <code>swift520.com</code>, 成功!~</p>
<p><img src="/images/com/10.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;文章以阿里云的.com域名为例子, 你也可以购买其他后缀的域名.&lt;/p&gt;
&lt;h2 id=&quot;购买&quot;&gt;&lt;a href=&quot;#购买&quot; class=&quot;
    
    </summary>
    
      <category term="Hexo" scheme="http://zedxpp.com/categories/Hexo/"/>
    
    
      <category term="配置Hexo域名" scheme="http://zedxpp.com/tags/%E9%85%8D%E7%BD%AEHexo%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>图片并茂教你搭建hexo博客,部署github,更换主题</title>
    <link href="http://zedxpp.com/2017/03/05/%E5%9B%BE%E7%89%87%E5%B9%B6%E8%8C%82%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2,%E9%83%A8%E7%BD%B2github,%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98/"/>
    <id>http://zedxpp.com/2017/03/05/图片并茂教你搭建hexo博客,部署github,更换主题/</id>
    <published>2017-03-05T14:48:33.000Z</published>
    <updated>2018-01-10T07:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="必备环境"><a href="#必备环境" class="headerlink" title="必备环境"></a>必备环境</h2><ul>
<li><p>Git(安装了Xcode就会自带, 所以不再赘述)</p>
</li>
<li><p>Node.js<br>可以用很多种方式安装Node.js, 但是为了必免因缺少各种环境而安装失败, 这里推荐直接下载安装包安装.<br><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="external">https://nodejs.org/zh-cn/download/</a></p>
</li>
</ul>
<p><img src="/images/hexoblog/1.png" alt=""></p>
<ul>
<li>Hexo</li>
</ul>
<p>打开终端, 输入<code>npm install -g hexo-cli</code>进行安装.</p>
<h2 id="搭建本地Hexo"><a href="#搭建本地Hexo" class="headerlink" title="搭建本地Hexo"></a>搭建本地Hexo</h2><p>Hexo只是帮你生成静态网页博客的工具, 你可以在本地进行调试. 如果你想让别人也能看到. 你必须上传到github或者自己的vps服务器. 别急, 接下来我都会为你讲解如何操作.</p>
<p>1.为了测试方便, 我把我的本地环境搭建在桌面的某个文件夹. 你也可以存放到你想存放的文件夹去.</p>
<p>注: 如果你想存放到别的地方, 那么你需要打开想存放的地方, 并且cd进去, 拖拽目标文件夹到终端, 既可获取目标路径, 拷贝路径, 然后cd进去既可.</p>
<p><img src="/images/hexoblog/2.png" alt=""><br><img src="/images/hexoblog/3.png" alt=""><br><img src="/images/hexoblog/4.png" alt=""></p>
<p>2.打开终端, 输入<code>cd Desktop</code>到桌面.</p>
<p>3.我准备把环境搭建在桌面的<code>peng</code>文件夹中, 所以我继续在终端输入<code>mkdir peng</code>创建名叫peng的文件夹.</p>
<p>4.<code>cd peng</code>进入叫<code>peng</code>的文件夹中.</p>
<p>5.输入<code>hexo init</code>进行初始化.</p>
<p><img src="/images/hexoblog/5.png" alt=""></p>
<p>6.输入<code>npm install</code>进行安装, 过一会儿会卡在<code>&gt; node scripts/install.js</code>这里, 你继续等待既可, 当出现如下图片, 安装成功.</p>
<p><img src="/images/hexoblog/6.png" alt=""></p>
<p>7.输入<code>npm install hexo-deployer-git --save</code>安装简化命令的插件.</p>
<p><img src="/images/hexoblog/7.png" alt=""></p>
<p>8.输入<code>hexo s</code>, 并且拷贝地址<code>http://0.0.0.0:4000/</code>到浏览器, 进行本地预览.  </p>
<p><img src="/images/hexoblog/8.png" alt=""></p>
<p><img src="/images/hexoblog/9.png" alt=""></p>
<p>9.对, 就是这么简单, 本地环境搭建成功. 按<code>control + c</code>退出预览.<code>不要关掉终端, 待会所有的操作, 都要在这个叫peng的文件夹中操作</code></p>
<p>10.接下来我们需要让本地环境生成静态网页, 并且上传到github中.</p>
<h2 id="部署博客到github-pages"><a href="#部署博客到github-pages" class="headerlink" title="部署博客到github pages"></a>部署博客到github pages</h2><p>1.打开github.com并且登录你的账号, 账号必须已经通过了邮箱认证<code>点击 Verify email address 链接验证邮箱</code>, 否则可能导致部署失败出现404. 在你注册账号的时候, github就会发送邮件到你的邮箱.</p>
<p><img src="/images/hexoblog/13.png" alt=""></p>
<p>2.登录账号后, 点击右上角的github头像, 点击Your profile.</p>
<p><img src="/images/hexoblog/14.png" alt=""></p>
<p>3.然后将浏览器地址栏,红框框起来的<code>github用户名</code>记录下来.</p>
<p><img src="/images/hexoblog/15.png" alt=""></p>
<p>4.点击右上角的<code>+</code>号按钮, 创建新的仓库.</p>
<p><img src="/images/hexoblog/16.png" alt=""></p>
<p>5.仓库名必须是你的<code>用户名.github.io</code>组成, 其他的都可以不用管, 填完仓库名后, 直接Create repository既可.</p>
<p><img src="/images/hexoblog/17.png" alt=""></p>
<p>6.点击按钮复制并且记录<code>仓库地址</code>, 待会要用到.</p>
<p><img src="/images/hexoblog/18.png" alt=""></p>
<p>7.在终端输入<code>open _config.yml</code>, 打开hexo配置文件, 滑动到最下面, 找到<code>deploy</code>, <code>repository</code>和<code>branch</code>这两个默认没有, 你按我的格式粘贴既可.</p>
<p><code>type后面写git, repository后面是你刚刚复制并记录的仓库地址, branch直接写master既可, 然后保存并关闭</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">    type: git </div><div class="line">    repository: https://github.com/pengpengtest/pengpengtest.github.io.git</div><div class="line">    branch: master</div></pre></td></tr></table></figure>
<p><img src="/images/hexoblog/19.png" alt=""></p>
<p>8.输入<code>hexo g -d</code>, 重新生成并部署网页到github仓库.期间会让你输入账号和密码.账号和密码每输入完一项回车既可.密码是不会显式出现的.</p>
<p><img src="/images/hexoblog/20.png" alt=""></p>
<p><img src="/images/hexoblog/21.png" alt=""></p>
<p>9.出现下图,表示部署博客到github仓库成功.打开github仓库, 里面已经有了文件了. </p>
<p><img src="/images/hexoblog/22.png" alt=""></p>
<p><img src="/images/hexoblog/23.png" alt=""></p>
<p>10.接下来在浏览器输入<code>你的用户名.github.io</code>打开.博客已成功部署到github仓库!别人也可以通过这个地址<code>你的用户名.github.io</code>来访问你的博客了!</p>
<p><img src="/images/hexoblog/24.png" alt=""></p>
<h2 id="发布新文章"><a href="#发布新文章" class="headerlink" title="发布新文章"></a>发布新文章</h2><p>1.在终端输入<code>hexo n &quot;文章名&quot;</code>, 创建文章.并且用<code>open xxxxx</code>打开它. 写入文章内容.</p>
<p><img src="/images/hexoblog/25.png" alt=""></p>
<p><img src="/images/hexoblog/26.png" alt=""></p>
<p>2.分别输入<code>hexo g</code>(生成)和<code>hexo d</code>(部署)后, 或者直接<code>hexo g -d</code>后, 再打开<code>你的用户名.github.io</code>. 新的文章也发布成功了.(有时候可能需要清除一下浏览器缓存才行)</p>
<ul>
<li>分别输入<code>hexo g</code>和<code>hexo d</code>等效于<code>hexo g -d</code>.</li>
</ul>
<p><img src="/images/hexoblog/27.png" alt=""></p>
<h2 id="更换hexo主题"><a href="#更换hexo主题" class="headerlink" title="更换hexo主题"></a>更换hexo主题</h2><p>1.在搜索引擎搜索 <code>hexo theme</code> 既可.</p>
<p><img src="/images/hexoblog/28.png" alt=""></p>
<p>2.在这里, 我们用<code>iissnan/hexo-theme-next</code>主题来演示.首先进入你想用的主题github仓库, 拷贝仓库地址.</p>
<p><img src="/images/hexoblog/29.png" alt=""></p>
<p>3.在终端输入<code>git clone 主题仓库地址 theme/主题名字</code>.接下来一顿下载.</p>
<p><code>git clone https://github.com/iissnan/hexo-theme-next.git themes/iissnan</code></p>
<p><img src="/images/hexoblog/30.png" alt=""></p>
<p>4.下载完成后, 输入<code>open _config.yml</code>找到<code>theme</code>,修改hexo配置, 告诉hexo你想用的主题名字.</p>
<p><img src="/images/hexoblog/31.png" alt=""></p>
<p>5.接下来<code>hexo clean</code>清理缓存, <code>hexo g -d</code>重新生成博客并且部署. 打开<code>你的用户名.github.io</code>, 更换主题成功!(有时候可能需要清除一下浏览器缓存才行, 浏览器缓存就是这么麻烦, 你懂的)</p>
<p><img src="/images/hexoblog/32.png" alt=""></p>
<p><img src="/images/hexoblog/33.png" alt=""></p>
<p>6.以后想更换主题, 按这个步骤来就行了.清理缓存并不会删除你的文章, 可以放心操作.</p>
<h2 id="用github当图床"><a href="#用github当图床" class="headerlink" title="用github当图床"></a>用github当图床</h2><p>如果需要用github当图床, 可以把图片放到<code>本地hexo目录/source/</code>文件夹里面, 我是新建了一个<code>images</code>来存放的. 需要先部署和生成, 把图片放到github上, 才能通过链接找到.</p>
<p><img src="/images/hexoblog/35.png" alt=""></p>
<p>如果是直接放在<code>source</code>目录下, 那么你的图片链接地址就是<code>http://域名/图片名.图片后缀</code>.</p>
<p>比如:<code>http://zedxpp.com/favicon.ico</code>这个小图标, 我是做了https转发, 所以实际浏览器上显示的链接不一样(你可以直接拷贝我给的链接查看)</p>
<p>如果是放在二级目录下, 就需要加上目录名称, 比如我放在<code>images</code>下的这个头像, 那么就是<code>http://zedxpp.com/images/icon.jpg</code></p>
<p><img src="/images/hexoblog/36.png" alt=""></p>
<p><img src="/images/hexoblog/37.png" alt=""></p>
<h2 id="科普时间"><a href="#科普时间" class="headerlink" title="科普时间"></a>科普时间</h2><ul>
<li><p>重点: 所有<code>hexo xxx</code>的操作, 必须用终端<code>cd 你本地环境目录</code>下, 然后才能用<code>hexo xxx</code>操作.</p>
</li>
<li><p>有时候明明已经新建, 修改了文章, 或者改变了博客或主题的各种配置, 并且生成部署了, 还是不能显示, 可能是github还没缓存好, 稍微等半分钟的样子, 再看看. 不行就清理浏览器缓存. 还是不行, 就<code>hexo clean</code>清理本地缓存. 再重新生成和部署.</p>
</li>
</ul>
<h3 id="hexo本地环境介绍"><a href="#hexo本地环境介绍" class="headerlink" title="hexo本地环境介绍"></a>hexo本地环境介绍</h3><p><img src="/images/hexoblog/34.png" alt=""></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_config.yml 用来存放hexo博客的个人描述, 博客小图标地址, 头像地址等等.</div><div class="line">source下的_posts 存放你所有的博文.md文件 你可以通过 hexo n "xxx" 创建博客文章, 也可以直接把xxx.md 格式的文件直接拖入进去</div><div class="line">themes 存放你的所有主题文件</div></pre></td></tr></table></figure>
<h3 id="各种hexo-xxx操作"><a href="#各种hexo-xxx操作" class="headerlink" title="各种hexo xxx操作"></a>各种hexo xxx操作</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hexo clean 清理缓存, 一般是在配置不能生效, 或者文章发布了不显示, 等等异常情况下使用的. 当然有时候清除浏览器缓存也是必须的操作.</div><div class="line">hexo g 重新生成静态网页, 所有发布文章, 修改文章, 修改hexo配置, 修改主题配置等等操作, 都需要.</div><div class="line">hexo d 让你的静态网页从本地部署到github</div><div class="line">hexo s 你可以边写文章, 边使用这个命令在本地预览, 包括修改各种配置, 都可以预览.</div></pre></td></tr></table></figure>
<h3 id="必备语法和工具"><a href="#必备语法和工具" class="headerlink" title="必备语法和工具"></a>必备语法和工具</h3><ul>
<li><p>使用hexo博客, 你需要会<code>markdown</code>语法, 才能编写更漂亮排版的文章.自行搜索<code>markdown 语法</code>关键字查找. </p>
</li>
<li><p>并且你需要一个能识别并编写<code>markdown</code>语法的编辑器. 自行搜索<code>markdown 编辑器</code>关键字查找. 各种免费的, 收费的.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;必备环境&quot;&gt;&lt;a href=&quot;#必备环境&quot; class=&quot;headerlink&quot; title=&quot;必备环境&quot;&gt;&lt;/a&gt;必备环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Git(安装了Xcode就会自带, 所以不再赘述)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Node.js&lt;br
    
    </summary>
    
      <category term="Hexo" scheme="http://zedxpp.com/categories/Hexo/"/>
    
    
      <category term="搭建Hexo" scheme="http://zedxpp.com/tags/%E6%90%AD%E5%BB%BAHexo/"/>
    
      <category term="部署Hexo" scheme="http://zedxpp.com/tags/%E9%83%A8%E7%BD%B2Hexo/"/>
    
      <category term="更换Hexo主题" scheme="http://zedxpp.com/tags/%E6%9B%B4%E6%8D%A2Hexo%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>利用VPS搭建科学上网工具和个人博客(教程合集)</title>
    <link href="http://zedxpp.com/2017/02/25/%E5%88%A9%E7%94%A8VPS%E6%90%AD%E5%BB%BA%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E6%95%99%E7%A8%8B%E5%90%88%E9%9B%86)/"/>
    <id>http://zedxpp.com/2017/02/25/利用VPS搭建科学上网工具和个人博客(教程合集)/</id>
    <published>2017-02-25T14:34:53.000Z</published>
    <updated>2018-01-10T07:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从教程中, 你可以收获什么?</p>
<ol>
<li>如何购买搬瓦工vps</li>
<li>如何使用搬瓦工vps后台</li>
<li>如何搭建Shadowsocks Sever来实现多终端翻墙.</li>
<li><a href="http://zedxpp.com/2017/03/05/%E5%9B%BE%E7%89%87%E5%B9%B6%E8%8C%82%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2,%E9%83%A8%E7%BD%B2github,%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98/">如何搭建个人hexo博客, 如何用github当博客图床, 更换hexo主题</a></li>
<li><a href="http://zedxpp.com/2017/03/05/%E4%B8%BA%E4%BD%A0%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%B8%AA%E6%80%A7%E5%9F%9F%E5%90%8D/">如何为博客配置个性域名</a></li>
<li><del>如何使用vps存放个人博客</del></li>
<li><del>如何使用vps当图床</del></li>
<li><del>如何为博客配置https</del></li>
</ol>
<p>以上内容都是我全部亲测过, 中横线部分, 会在下来的日子更新, 请持续关注.</p>
<ul>
<li><p>搭建一个翻墙工具, 上google找文章, 存放个人博客, 把vps当图床, 都还是比较值得的.毕竟入门款的vps, 算上优惠码, 一年也仅仅只需要19美刀左右.</p>
</li>
<li><p>文章收集了从购买vps, 搭建Shadowsocks, 搭建Ipsec等一系列文章. 并结合自己使用时碰到的问题, 一一分享给大家. </p>
</li>
<li>文章内容, 假设阅读者是没有任何购买和搭建vps的经验, 所以会尽量讲解的比较仔细. 文章内容均以搬瓦工vps来讲解.</li>
<li>以下购买和登录后台的教程来自<a href="http://banwagong.cn/" target="_blank" rel="external">http://banwagong.cn/</a>, 实际操作均在搬瓦工官网.</li>
</ul>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>vps: 搬瓦工<br>工具: Mac终端</p>
<h2 id="购买和使用"><a href="#购买和使用" class="headerlink" title="购买和使用"></a>购买和使用</h2><p>注: 搬瓦工vps支付方式支持</p>
<ul>
<li>PayPal</li>
<li>AliPay</li>
<li>Credit Card(Stripe)</li>
</ul>
<ol>
<li><p><a href="https://bwh1.net" target="_blank" rel="external">搬瓦工官网</a></p>
</li>
<li><p><a href="http://banwagong.cn/" target="_blank" rel="external">搬瓦工购买方案</a></p>
</li>
<li><p><a href="http://banwagong.cn/gonglue.html" target="_blank" rel="external">图文并茂购买指导教程</a>  注: 购买时长分月付, 季度付, 半年付, 年付</p>
</li>
<li><p><a href="http://banwagong.cn/jichu.html" target="_blank" rel="external">选择登录已购VPS方案面板</a></p>
</li>
</ol>
<p>注: 不知道你自己的服务器ip和密码, 用此方式登录<br>已知你的服务器ip和密码, 可以直接进入<a href="https://kiwivm.64clouds.com/" target="_blank" rel="external">搬瓦工面板登录</a></p>
<h4 id="教程中的vps系统都是centos-6-x86的-请安装一致"><a href="#教程中的vps系统都是centos-6-x86的-请安装一致" class="headerlink" title="教程中的vps系统都是centos-6-x86的.请安装一致."></a>教程中的vps系统都是centos-6-x86的.请安装一致.</h4><p><img src="/images/20170225213251/14880213549019.jpg" alt=""></p>
<hr>
<p><a href="http://banwagong.cn/genghuan.html" target="_blank" rel="external">自主任意更换机房实现换IP</a> (无此需求可略过)</p>
<p><a href="http://banwagong.cn/anzhuang.html" target="_blank" rel="external">重新安装Linux系统过程及注意事项</a> (无此需求可略过)</p>
<p>注: 切换机房ip和重装系统, 请先stop服务器<br><img src="/images/20170225213251/14880199458363.jpg" alt=""></p>
<hr>
<h2 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h2><p>建议大家购买搬瓦工vps后, 从官网的已购列表进入kiwivm面板, 记录自己的ip地址, 并更改kiwivm面板的密码. 避免每次进入kiwivm面板都要从官网操作好几步才能进.</p>
<p><a href="https://kiwivm.64clouds.com/" target="_blank" rel="external">kiwivm搬瓦工面板登录入口</a></p>
<h3 id="ip地址查看-教程中的ip地址都是这个"><a href="#ip地址查看-教程中的ip地址都是这个" class="headerlink" title="ip地址查看(教程中的ip地址都是这个)"></a>ip地址查看(教程中的ip地址都是这个)</h3><p><img src="/images/20170225213251/14880208219830.jpg" alt=""></p>
<h3 id="修改kiwivm面板密码"><a href="#修改kiwivm面板密码" class="headerlink" title="修改kiwivm面板密码"></a>修改kiwivm面板密码</h3><p><img src="/images/20170225213251/14880208634025.jpg" alt=""></p>
<h2 id="一键搭建Shadowsocks"><a href="#一键搭建Shadowsocks" class="headerlink" title="一键搭建Shadowsocks"></a>一键搭建Shadowsocks</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>Shadowsocks可以在Windows/Mac/iPhone系统上使用.</p>
<p><a href="https://github.com/shadowsocks/shadowsocks-windows/wiki/Shadowsocks-Windows-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="external">windows下载地址</a></p>
<p><a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-%E5%B8%AE%E5%8A%A9" target="_blank" rel="external">mac下载地址</a></p>
<p><a href="https://itunes.apple.com/cn/app/wingy-http-s-socks5-proxy-utility/id1178584911?mt=8" target="_blank" rel="external">iphoneApp下载地址</a></p>
<h3 id="安装Shadowsocks-Sever"><a href="#安装Shadowsocks-Sever" class="headerlink" title="安装Shadowsocks Sever"></a>安装Shadowsocks Sever</h3><ul>
<li>在左边部分菜单栏滑动到底部, 点击shadowsocks sever之后, 如果没有安装过shadowsocks sever, 就需要点击install来一键安装shadowsocks sever.</li>
<li>请记录页面上的port和password.后面设置会用到.</li>
</ul>
<p><img src="/images/20170225213251/14880211240769.jpg" alt=""></p>
<p>Windows/Mac/iPhone上的shadowsocks软件设置都差不多, 所以这里只讲一种, 以mac为例</p>
<p>为方便讲解, 后面会统一叫Shadowsocks为小飞机!</p>
<h3 id="配置Shadowsocks软件"><a href="#配置Shadowsocks软件" class="headerlink" title="配置Shadowsocks软件"></a>配置Shadowsocks软件</h3><p>下载并打开软件后在状态栏找到软件, 对! 就是一个飞机的样子=. =</p>
<p><img src="/images/20170225213251/14880222141646.jpg" alt=""></p>
<p>红色框住的部分是我们可能会使用到.</p>
<ul>
<li>自动代理模式: 需要翻墙的会自动翻墙, 不需要的就不翻墙.</li>
<li>全局模式: 所有的都会翻墙.</li>
<li>服务器: 选择, 增加, 减少, 编辑服务器设定.</li>
<li>编辑自动模式的PAC: 如果你需要指定某个网站强制翻墙, 那么你需要点击它, 并且编辑gfwlist.js文件, 照着葫芦画瓢, 加上网站地址既可, 如果用mac自带的文本编辑来编辑文件, 请务必注意双引号的区别!!!否则可能导致无法使用小飞机.</li>
</ul>
<p><img src="/images/20170225213251/14880228934002.jpg" alt=""></p>
<ul>
<li><p>生成二维码和扫描二维码: 在iPhone上或者mac上, 为了快速的分享你的小飞机的服务器配置, 可能会使用到. 扫描一下生成的二维码, 既可添加配置. 不用你在多设备的时候输入N遍.</p>
</li>
<li><p>帮助: 当你想下载最新的小飞机版本, 或者找不到小飞机下载地址, 可以点它.</p>
</li>
</ul>
<p><img src="/images/20170225213251/14880224043452.jpg" alt=""></p>
<p>在图中填入服务器ip地址, 填入刚刚在shadowsocks sever中的prot端口号和密码, 加密方式不动它. 备注随便填~然后点击确定既可.接下来就是打开浏览器, 输入google.com来测试你的成果~</p>
<p>iPhone/iPad实现VPN翻墙, 有两种方式.</p>
<ul>
<li>一种是使用<a href="https://itunes.apple.com/cn/app/wingy-http-s-socks5-proxy-utility/id1178584911?mt=8" target="_blank" rel="external">Wingy - Http(s),Socks5 Proxy Utility</a>这个app软件+之前配置的Shadowsocks Sever来实现, 并且软件支持Widget一键翻墙.</li>
<li>一种是需要在vps服务器安装ipsec, 稍微比较麻烦点. 并且需要在设置-&gt;通用-&gt;VPN中配置一次. 但是不需要下载任何软件. 以后使用, 直接打开设置&gt;打开VPN既可.(我个人是比较喜欢这种方式, 不想安装软件)</li>
</ul>
<p>如果你选择了第二种方式, 那么, 请接着往下看.</p>
<h2 id="在VPS上配置iPsec"><a href="#在VPS上配置iPsec" class="headerlink" title="在VPS上配置iPsec"></a>在VPS上配置iPsec</h2><p>以下内容均来自<a href="https://quericy.me/blog/699/" target="_blank" rel="external">https://quericy.me/blog/699/</a>, 我只是在他的教程基础上进行了重新整理, 并补充了一些说明, 让你更快的配置iPsec, 所以你直接按照我的步骤来既可.</p>
<ul>
<li>接下来会使用vim编辑内容, 如果你不会vim, 那么请点开查看<a href="http://www.jianshu.com/p/c03ee7b6e1e8" target="_blank" rel="external">vim的简单使用</a>.如果你会vim的使用, 那么请继续往下看.</li>
</ul>
<p>1.打开root shell - interactive, 点击launch<br><img src="/images/20170225213251/14880262928954.jpg" alt=""></p>
<p>2.界面会跳转并变大变小几次来进行加载, 然后输入passwd, 修改服务器密码, 服务器密码和kiwivm后台是两个互不干扰的密码, 但是建议改成一样.输入新密码, 回车, 再次输入, 回车, 出现下图最后一句话, 表示密码修改成功.<br><img src="/images/20170225213251/14880263846376.jpg" alt=""></p>
<p>3.打开kiwivm首页, 找到ip地址和ssh port端口地址并记录下来<br><img src="/images/20170225213251/14880266281824.jpg" alt=""></p>
<p>4.打开mac终端, 输入<code>ssh root@你的ip地址 -p SSH Port端口号</code><br>如: <code>ssh root@192.192.192.192 -p 28400</code></p>
<p>5.会提示你输入密码, 输入刚刚修改的服务器密码.出现<code>[root@localhost ~]#</code>表示连接成功.</p>
<p><img src="/images/20170225213251/14880268233754.jpg" alt=""></p>
<p>6.输入 <code>wget --no-check-certificate https://raw.githubusercontent.com/quericy/one-key-ikev2-vpn/master/one-key-ikev2.sh</code><br>7.等进度走完了, 继续输入<code>chmod +x one-key-ikev2.sh</code><br>8.输入<code>bash one-key-ikev2.sh</code><br>9.出现这个时, 请输入<code>2</code>并回车<br><img src="/images/20170225213251/14880255324341.jpg" alt=""></p>
<p><img src="/images/20170225213251/14880257032609.jpg" alt=""></p>
<p>10.接下来只要有停顿, 也是直接回车既可.<br>11.当出现<code>install complete</code>, 说明安装成功了.<br><img src="/images/20170225213251/14880259925620.jpg" alt=""></p>
<p>12.打开sysctl文件, 输入<code>vim /etc/sysctl.conf</code><br>修改<code>net.ipv4.ip_forward = 1</code>, 把<code>0</code>改成<code>1</code><br>找到以下四个, 分别在每句最前面加上#把当前行注释掉.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">net.bridge.bridge-nf-call-ip6tables</div><div class="line">net.bridge.bridge-nf-call-iptables</div><div class="line">net.bridge.bridge-nf-call-arptables</div><div class="line">net.nf_conntrack_max</div></pre></td></tr></table></figure>
<p>如: <code>#net.bridge.bridge-nf-call-ip6tables......</code></p>
<p>13.使用以下指令刷新sysctl, 输入：<code>sysctl -p</code></p>
<p>14.输入<code>vim /usr/local/etc/ipsec.secrets</code>并编辑, 编辑完后保存并退出编辑.</p>
<p>账号格式: <code>账号 %any : EAP &quot;密码&quot;</code>, 密码用<code>&quot;&quot;</code>双引号包起来, 如果你只需要一个, 就添加一个, 如果需要多个, 换行添加.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">: RSA server.pem</div><div class="line">: PSK "myPSKkey"</div><div class="line">: XAUTH "myXAUTHPass"</div><div class="line">peng %any : EAP "123456"</div><div class="line">peng2 %any : EAP "123456"</div></pre></td></tr></table></figure>
<p>15.输入<code>ipsec start</code>启动ipsec</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ipsec常用指令</div><div class="line">ipsec start   #启动服务</div><div class="line">ipsec stop    #关闭服务</div><div class="line">ipsec restart #重启服务</div><div class="line">ipsec reload  #重新读取</div><div class="line">ipsec status  #查看状态</div><div class="line">ipsec --help  #查看帮助</div></pre></td></tr></table></figure>
<p>16.服务器重启后, ipsec是不会自动启动的, 所以我们需要把它添加到自启动.在终端输入<code>vim /etc/rc.local</code>,添加<code>/usr/local/sbin/ipsec start</code></p>
<p>添加后如图:<br><img src="/images/20170225213251/14880276182551.jpg" alt=""></p>
<p>17.然后打开手机, 设置-&gt;通用-&gt;VPN-&gt;添加VPN配置</p>
<p>下图中的PSK是有用的<br><img src="/images/20170225213251/14880278856543.jpg" alt=""><br><img src="/images/20170225213251/14880280151318.jpg" alt=""></p>
<p>18.点击完成后, 回到VPN页面点连接既可.</p>
<p>19.如果你的手机上没有装任何小飞机的软件, 你后续使用, 就直接点这个就可以了.否则你需要进到 设置-&gt;通用-&gt;VPN-&gt;连接.</p>
<p><img src="/images/20170225213251/14880281376766.jpg" alt=""></p>
<h2 id="未完待续-请关注我"><a href="#未完待续-请关注我" class="headerlink" title="未完待续, 请关注我!~"></a>未完待续, 请关注我!~</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从教程中, 你可以收获什么?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何购买搬瓦工vps&lt;/li&gt;
&lt;li&gt;如何使用搬瓦工vps后台&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="VPS" scheme="http://zedxpp.com/categories/VPS/"/>
    
    
      <category term="VPS科学上网" scheme="http://zedxpp.com/tags/VPS%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Vim的简单使用</title>
    <link href="http://zedxpp.com/2017/02/25/Vim%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://zedxpp.com/2017/02/25/Vim的简单使用/</id>
    <published>2017-02-25T14:34:07.000Z</published>
    <updated>2018-01-21T02:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>为配合教程, 所以简单的介绍下vim的基础使用.</p>
<p>当你在终端输入<code>vi xxx</code>或者<code>vim xxx</code>的后.会进入下图的状态, 请多注意左下角, 每一个步骤左下角都会有变化.</p>
<p>1.未编辑状态<br><img src="http://zedxpp.com/images/20170225221630/QQ20170225-221338@2x.png" alt=""></p>
<p>2.按键盘上的<code>i</code>进入编辑状态, 然后输入内容<br>输入前<br><img src="http://zedxpp.com/images/20170225221630/QQ20170225-221348@2x.png" alt=""><br>输入后<br><img src="http://zedxpp.com/images/20170225221630/QQ20170225-221354@2x.png" alt=""></p>
<p>3.按<code>esc</code>退出编辑状态<br><img src="http://zedxpp.com/images/20170225221630/QQ20170225-221401@2x.png" alt=""></p>
<p>4.输入<code>:wq</code>保存并退出<br><img src="http://zedxpp.com/images/20170225221630/QQ20170225-221412@2x.png" alt=""></p>
<p>5.保存并退出后<br><img src="http://zedxpp.com/images/20170225221630/QQ20170225-221420@2x.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为配合教程, 所以简单的介绍下vim的基础使用.&lt;/p&gt;
&lt;p&gt;当你在终端输入&lt;code&gt;vi xxx&lt;/code&gt;或者&lt;code&gt;vim xxx&lt;/code&gt;的后.会进入下图的状态, 请多注意左下角, 每一个步骤左下角都会有变化.&lt;/p&gt;
&lt;p&gt;1.未编辑状态&lt;br&gt;&lt;i
    
    </summary>
    
      <category term="Vim" scheme="http://zedxpp.com/categories/Vim/"/>
    
    
      <category term="Vim使用" scheme="http://zedxpp.com/tags/Vim%E4%BD%BF%E7%94%A8/"/>
    
      <category term="VPS" scheme="http://zedxpp.com/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>Quartz2D</title>
    <link href="http://zedxpp.com/2016/05/08/Quartz2D/"/>
    <id>http://zedxpp.com/2016/05/08/Quartz2D/</id>
    <published>2016-05-08T08:22:53.000Z</published>
    <updated>2016-05-08T08:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quartz2D简介"><a href="#Quartz2D简介" class="headerlink" title="Quartz2D简介"></a>Quartz2D简介</h2><ul>
<li>Quartz 2D是一个二维图形绘制引擎，支持iOS环境和Mac OS X环境。<br></li>
<li>Quartz 2D以PDF的规范为基础的图形库，用来绘制二维文字和图形，允许相同的绘图指令在任何装置上，使用可以得到的最佳分辨率，产生相同的输出。<br></li>
<li>Quartz 2D API可以实现许多功能，如基于路径的绘图、透明度、阴影、颜色管理、反锯齿、PDF文档生成和PDF元数据访问等。 <a id="more"></a></li>
<li>Quartz 2D API是Core Graphics框架的一部分，因此其中的很多数据类型和方法都是以CG开头的。会经常见到Quartz 2D（Quartz）和Core Graphics两个术语交互使用。</li>
<li>Quartz 2D与分辨率和设备无关，因此在使用Quartz 2D绘图时，无需考虑最终绘图的目标设备。</li>
</ul>
<h6 id="注"><a href="#注" class="headerlink" title="注:"></a>注:</h6><p>本文内容均来自, 我自己学习过程中的整理, Quartz2D介绍部分来自 <a href="http://www.cnblogs.com/monicaios/p/3516733.html" target="_blank" rel="external">Rynn的博客</a> 具体更详细的Quartz2D介绍可以点击链接查看, 本博文主要以实战代码为主.</p>
<hr>
<h3 id="学习Quartz2D必须了解的方法-void-drawRect-CGRect-rect"><a href="#学习Quartz2D必须了解的方法-void-drawRect-CGRect-rect" class="headerlink" title="学习Quartz2D必须了解的方法   - (void)drawRect:(CGRect)rect"></a>学习Quartz2D必须了解的方法   - (void)drawRect:(CGRect)rect</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">	<span class="comment">// Drawing code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对View进行绘制, 必须在这个方法内进行codeing.</li>
<li>因为只有在这个方法中才能获取到跟View相关联的上下文.(系统内部会创建好上下文, 我们只需要直接get获取就好)</li>
<li>当View即将显示的时候, 会自动调用这个方法.</li>
<li><code>- (void)drawRect:(CGRect)rect</code> 中的rect参数, 可以获取到当前View的CGRect</li>
</ul>
<hr>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol>
<li>新建项目, 在项目里面创建一个UIView.</li>
<li>自定义一个继承UIView的类, 并且让创建出来的UIView的类型, 继承自你刚刚自定义的那个类. </li>
<li>接下来我们就可以在刚刚自定义的类, <code>- (void)drawRect:(CGRect)rect</code>的方法中愉快的玩耍了.</li>
<li>一般新建一个继承自UIView的类, 在.m中会自动帮我们生成好<code>- (void)drawRect:(CGRect)rect</code>方法, 我们只需要打开就好.</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"DrawView.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DrawView</span></span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">// Only override drawRect: if you perform custom drawing.</div><div class="line">// An empty implementation adversely affects performance during animation.</div><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    // Drawing code</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h3><h4 id="画一条直线"><a href="#画一条直线" class="headerlink" title="画一条直线"></a>画一条直线</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    <span class="comment">// 获取图形上下文(在 drawRect: 方法中, 系统已经帮我们创建好了图形上下文)</span></div><div class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    </div><div class="line">    <span class="comment">// 创建路径</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置起点</span></div><div class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">100</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">// 添加一条线到某个点</span></div><div class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">200</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">// 添加路径到图形上下文</span></div><div class="line">    <span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</div><div class="line">    </div><div class="line">    <span class="comment">// 绘制</span></div><div class="line">    <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0001.png" alt=""> </p>
<ul>
<li>两点成一线, 所以我们设置起点, 设置终点, 就可以画线</li>
<li><code>CGContextAddPath(ctx, path.CGPath);</code> 因为这个函数需要接收的参数是<code>CGPathRef</code>, 而我们创建的并不是, 所以我们需要调用<code>UIBezierPath</code>类的<code>- (CGPathRef)CGPath</code>方法, 把 <code>UIBezierPath</code>类型转换成<code>CGPathRef</code>.</li>
</ul>
<hr>
<h4 id="画两条直线"><a href="#画两条直线" class="headerlink" title="画两条直线"></a>画两条直线</h4><ul>
<li><p>想要实现画两条或多条直线的方法, 有两种方式.</p>
</li>
<li><p>第一种</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    <span class="comment">// 获取图形上下文(在 drawRect: 方法中, 系统已经帮我们创建好了图形上下文)</span></div><div class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    </div><div class="line">    <span class="comment">// 创建路径</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置起点</span></div><div class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">100</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置终点</span></div><div class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">200</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">// 一个路径对象可以包含很多线段, 所以我们可以继续设置起点</span></div><div class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">200</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置终点</span></div><div class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">200</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">// 添加路径到图形上下文</span></div><div class="line">    <span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</div><div class="line">    </div><div class="line">    <span class="comment">// 绘制</span></div><div class="line">    <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0002.png" alt=""></p>
<ul>
<li>第二种</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    <span class="comment">// 获取图形上下文(在 drawRect: 方法中, 系统已经帮我们创建好了图形上下文)</span></div><div class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    </div><div class="line">    <span class="comment">// 创建路径</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置起点</span></div><div class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">100</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置终点</span></div><div class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">200</span>)];</div><div class="line">   </div><div class="line">    <span class="comment">// 添加路径到图形上下文</span></div><div class="line">    <span class="built_in">CGContextAddPath</span>(ctx, path.CGPath); </div><div class="line">    </div><div class="line">    <span class="comment">// 因为上一个路径已经添加到了图形上下文中了, 所以我们可以重新创建一个UIBezierPath对象, </span></div><div class="line">    <span class="comment">// 来改变path的指针指向.</span></div><div class="line">    path = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置起点,移动到某个位置</span></div><div class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">30</span>, <span class="number">200</span>)];</div><div class="line"></div><div class="line">    <span class="comment">// 设置终点</span></div><div class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">200</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">// 添加路径到图形上下文</span></div><div class="line">    <span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</div><div class="line">    </div><div class="line">    <span class="comment">// 绘制</span></div><div class="line">    <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0003.png" alt=""></p>
<ul>
<li>对比完两种方法, 第二种方法比第一种方法多了几个步骤, 1.重新创建新的路径 2.设置起点, 终点 3.添加路径到上下文.</li>
<li>从实用角度来讲, 我个人更倾向于第二种, <code>自己的路径, 自己的路径对象进行管理</code>, 从代码行数角度来讲, 当然是第一种好.</li>
<li>上面所讲的方法是用来绘制<code>平行或无连接关系</code>的线段.</li>
</ul>
<hr>
<h4 id="画有-连接关系-的线段和设置线段的属性"><a href="#画有-连接关系-的线段和设置线段的属性" class="headerlink" title="画有 连接关系 的线段和设置线段的属性"></a>画有 连接关系 的线段和设置线段的属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">	 <span class="comment">// 获取图形上下文</span></div><div class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    </div><div class="line">    <span class="comment">// 创建路径</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置起点</span></div><div class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">30</span>, <span class="number">100</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置终点</span></div><div class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">200</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置第二根线的终点</span></div><div class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">100</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">// 添加路径到图形上下文</span></div><div class="line">    <span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</div><div class="line">    </div><div class="line">    <span class="comment">// 设置线宽</span></div><div class="line">    <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">10</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 设置线条两端的样式为圆角</span></div><div class="line">    <span class="built_in">CGContextSetLineCap</span>(ctx, kCGLineCapRound);</div><div class="line"></div><div class="line">    <span class="comment">// 设置线条连接处的样式为圆角</span></div><div class="line">    <span class="built_in">CGContextSetLineJoin</span>(ctx, kCGLineJoinRound);</div><div class="line">    </div><div class="line">	 <span class="comment">// 绘制</span></div><div class="line">    <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0004.png" alt=""></p>
<ul>
<li>如果画的线段是连接在一起的, 可以直接设置第二根线的终点, 不必重现设置起点.</li>
<li>设置线条<code>两端的样式</code>和<code>连接处的样式</code>的参数是枚举, 剩下的样式请自行尝试.</li>
</ul>
<hr>
<h4 id="UIBezierPath"><a href="#UIBezierPath" class="headerlink" title="UIBezierPath"></a>UIBezierPath</h4><ul>
<li>因为UIBezierPath类里面已经帮我们封装好了很多东西, 所以绘制线段有更快捷的方法.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line"></div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">    </div><div class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">50</span>)];</div><div class="line">    </div><div class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">200</span>)];</div><div class="line">    </div><div class="line">    [path stroke];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0005.png" alt=""></p>
<hr>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">绘制步骤可以分成四个大的步骤</div><div class="line"></div><div class="line">1. 获取当前View的图形上下文</div><div class="line">2. 创建路径</div><div class="line">	2.1 设置起点</div><div class="line">	2.2 设置终点</div><div class="line">	2.3 ....</div><div class="line">3. 添加路径到图形上下文</div><div class="line">4. 绘制</div></pre></td></tr></table></figure>
<hr>
<h3 id="绘制基本图形"><a href="#绘制基本图形" class="headerlink" title="绘制基本图形"></a>绘制基本图形</h3><h4 id="矩形和正方形"><a href="#矩形和正方形" class="headerlink" title="矩形和正方形"></a>矩形和正方形</h4><h5 id="正方形"><a href="#正方形" class="headerlink" title="正方形"></a>正方形</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    <span class="comment">// 第一个参数表示需要绘制图形的frame, 第二个参数表示半径(可以通过修改这个参数来达到绘制带圆角的图形和绘制圆形)</span></div><div class="line">   <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">160</span>, <span class="number">160</span>) cornerRadius:<span class="number">0</span>];</div><div class="line"></div><div class="line">    [path stroke];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0006.png" alt=""></p>
<h5 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    </div><div class="line">   <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">160</span>, <span class="number">100</span>) cornerRadius:<span class="number">20</span>];</div><div class="line"></div><div class="line">    [path stroke];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0007.png" alt=""></p>
<h5 id="圆型"><a href="#圆型" class="headerlink" title="圆型"></a>圆型</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    </div><div class="line">   <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">150</span>, <span class="number">150</span>) cornerRadius:<span class="number">75</span>];</div><div class="line"></div><div class="line">    [path stroke];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0008.png" alt=""></p>
<ul>
<li>这里只放置3种样式的代码, 其他样式可以修改参数, 通过这个方法来绘制正方形, 矩形, 圆角正方形, 圆角矩形, 圆形,等…</li>
</ul>
<hr>
<h4 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">100</span>)];</div><div class="line">    [path stroke];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0009.png" alt=""></p>
<ul>
<li>用以上方法同样也可以绘制圆形</li>
</ul>
<hr>
<h4 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    <span class="comment">// 获取当前控件的圆心</span></div><div class="line">    <span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(rect.size.width * <span class="number">0.5</span>, rect.size.height * <span class="number">0.5</span>);</div><div class="line">    <span class="comment">// 获取半径</span></div><div class="line">    <span class="built_in">CGFloat</span> radius = rect.size.width * <span class="number">0.5</span> * <span class="number">0.5</span>;</div><div class="line">    <span class="comment">/*</span></div><div class="line">    参数一 需要绘制圆弧的圆心在哪, </div><div class="line">    参数二 圆弧到圆心的半径, </div><div class="line">    参数三 圆弧开始角度, </div><div class="line">    参数四 圆弧结束角度, </div><div class="line">    参数五 传入YES表示顺时针, 传入NO表示逆时针</div><div class="line">    */</div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:radius startAngle:<span class="number">0</span> endAngle:M_PI clockwise:<span class="literal">YES</span>];</div><div class="line">    [path stroke];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0010.png" alt=""></p>
<ul>
<li>从以上图片可以看出, 开始角度并不是从12点钟方向开始的, 而是从3点钟方向开始的. 所以在绘制圆弧的时候需要注意, 如果需要从12点钟方向开始, 那么开始角度应该是-90度开始</li>
<li>在OC中, 已经定义好了一些常用的宏, <code>M_PI</code>表示180°, <code>M_PI_2</code>表示90°, <code>M_PI_4</code>表示45°.(具体可以跳到头文件进行查看)</li>
<li>具体角度与弧度互转, 引用至<code>百度知道</code>的答案<blockquote>
<p>弧度 ＝ (角度 / 180) <em> PI<br>PI就是“派”<br>比如180度角，转换之后的弧度就是PI，45度的话是四分之一PI。<br>反过来也一样，角度 = 弧度 / PI </em> 180</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="扇形"><a href="#扇形" class="headerlink" title="扇形"></a>扇形</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    <span class="comment">// 获取圆心</span></div><div class="line">    <span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(rect.size.width * <span class="number">0.5</span>, rect.size.height * <span class="number">0.5</span>);</div><div class="line">    <span class="comment">// 创建路径</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:<span class="number">100</span> startAngle:<span class="number">0</span> endAngle:M_PI_2 clockwise:<span class="literal">YES</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 添加一根线到圆心</span></div><div class="line">    [path addLineToPoint:center];</div><div class="line">    </div><div class="line">    <span class="comment">// 从圆心添加线到圆弧的起始点</span></div><div class="line">    <span class="comment">// [path addLineToPoint:CGPointMake(center.x + 100, center.y)];</span></div><div class="line">    </div><div class="line">    <span class="comment">// 关闭路径</span></div><div class="line">    [path closePath];</div><div class="line">       </div><div class="line">    <span class="comment">// 绘制</span></div><div class="line">    [path stroke];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0011.png" alt=""></p>
<ul>
<li>从上述代码可以看出, 绘制扇形, 其实就是先绘制圆弧, 然后添加一根线到圆心, 再添加一根线到圆弧的起始点位置, 就组成了一个扇形.</li>
<li><code>UIBezierPath</code>类为我们提供了更加便捷的方法, 所以在添加第二根线, <code>圆心到圆弧起始点位置</code>, 我们可以直接调用<code>[path closePath]</code>的对象方法, 这样也减少了位置的计算.</li>
</ul>
<hr>
<h5 id="扇形的描边和填充"><a href="#扇形的描边和填充" class="headerlink" title="扇形的描边和填充"></a>扇形的描边和填充</h5><h6 id="修改描边颜色"><a href="#修改描边颜色" class="headerlink" title="修改描边颜色"></a>修改描边颜色</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 此处省略创建路径等代码, 重点讲解如何描边</span></div><div class="line">    <span class="comment">// 关闭路径</span></div><div class="line">    [path closePath];</div><div class="line"></div><div class="line">    <span class="comment">// 设置描边颜色</span></div><div class="line">    [[<span class="built_in">UIColor</span> greenColor] setStroke];</div><div class="line"></div><div class="line">    <span class="comment">// 绘制</span></div><div class="line">    [path stroke];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0012.png" alt=""></p>
<ul>
<li>在关闭路径后, 绘制之前, 如果我们需要设置扇形的线条颜色, 可以通过<code>setStroke</code>方法来设置颜色.</li>
</ul>
<hr>
<h6 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    <span class="comment">// 获取圆心</span></div><div class="line">    <span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(rect.size.width * <span class="number">0.5</span>, rect.size.height * <span class="number">0.5</span>);</div><div class="line">    <span class="comment">// 创建路径</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:<span class="number">100</span> startAngle:<span class="number">0</span> endAngle:M_PI_2 clockwise:<span class="literal">YES</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 添加一根线到圆心</span></div><div class="line">    [path addLineToPoint:center];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置填充颜色</span></div><div class="line">    [[<span class="built_in">UIColor</span> blueColor] setFill];</div><div class="line">    </div><div class="line">    <span class="comment">// 填充</span></div><div class="line">    [path fill];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0013.png" alt=""></p>
<ul>
<li>如果你是需要填充扇形, 那么可以省略关闭路径这一步骤<code>closePath</code></li>
<li>并且不再是调用<code>stroke</code>方法, 而是调用<code>fill</code>方法</li>
</ul>
<hr>
<h6 id="同时填充和描边"><a href="#同时填充和描边" class="headerlink" title="同时填充和描边"></a>同时填充和描边</h6><ul>
<li>如果你需要同时填充和描边扇形, 那么<code>UIBezierPath</code>并没有帮我们封装类似的方法, 所以我们还是需要使用<code>CoreGraphics</code>框架中的C语言函数来实现.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    <span class="comment">// 获取圆心</span></div><div class="line">    <span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(rect.size.width * <span class="number">0.5</span>, rect.size.height * <span class="number">0.5</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取上下文</span></div><div class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    </div><div class="line">    <span class="comment">// 创建路径</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:<span class="number">100</span> startAngle:<span class="number">0</span> endAngle:M_PI_2 clockwise:<span class="literal">YES</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 添加一根线到圆心</span></div><div class="line">    [path addLineToPoint:center];</div><div class="line">    </div><div class="line">    <span class="comment">// 关闭路径</span></div><div class="line">    [path closePath];</div><div class="line">    </div><div class="line">    <span class="comment">// 把路径添加到上下文</span></div><div class="line">    <span class="built_in">CGContextAddPath</span>(ctx, path.CGPath);</div><div class="line">    </div><div class="line">    <span class="comment">// 设置填充颜色</span></div><div class="line">    [[<span class="built_in">UIColor</span> blueColor] setFill];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置描边颜色</span></div><div class="line">    [[<span class="built_in">UIColor</span> greenColor] setStroke];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置线宽</span></div><div class="line">    <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">5</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 渲染 (第二个形参表示绘画模式是填充和描边都需要, 这个参数是枚举)</span></div><div class="line">    <span class="built_in">CGContextDrawPath</span>(ctx, kCGPathFillStroke);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Quartz2D/0014.png" alt=""></p>
<ul>
<li>这里是需要关闭路径的, 不关闭会有问题. 你可以试试注释掉关闭路径的代码.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Quartz2D简介&quot;&gt;&lt;a href=&quot;#Quartz2D简介&quot; class=&quot;headerlink&quot; title=&quot;Quartz2D简介&quot;&gt;&lt;/a&gt;Quartz2D简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Quartz 2D是一个二维图形绘制引擎，支持iOS环境和Mac OS X环境。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Quartz 2D以PDF的规范为基础的图形库，用来绘制二维文字和图形，允许相同的绘图指令在任何装置上，使用可以得到的最佳分辨率，产生相同的输出。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Quartz 2D API可以实现许多功能，如基于路径的绘图、透明度、阴影、颜色管理、反锯齿、PDF文档生成和PDF元数据访问等。
    
    </summary>
    
      <category term="Quartz2D" scheme="http://zedxpp.com/categories/Quartz2D/"/>
    
    
      <category term="Quartz2D" scheme="http://zedxpp.com/tags/Quartz2D/"/>
    
  </entry>
  
  <entry>
    <title>Swift导入SQLite库, Swift桥接OC 步骤</title>
    <link href="http://zedxpp.com/2016/04/14/Swift%E5%AF%BC%E5%85%A5SQLite%E5%BA%93,%20Swift%E6%A1%A5%E6%8E%A5OC%20%E6%AD%A5%E9%AA%A4/"/>
    <id>http://zedxpp.com/2016/04/14/Swift导入SQLite库, Swift桥接OC 步骤/</id>
    <published>2016-04-14T02:25:08.000Z</published>
    <updated>2018-01-21T02:45:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>注: 图中所用的Xcode版本为Xcode7.3</code></p>
<h2 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h2><p>按下图顺序进行导入SQLite库</p>
<a id="more"></a>
<p><img src="/images/Swift_SQLite_images/QQ20160414-0@2x.png" alt="QQ20160414-0@2x.png"> </p>
<p><img src="/images/Swift_SQLite_images/QQ20160414-2@2x.png" alt="QQ20160414-2@2x.png"></p>
<h2 id="桥接文件"><a href="#桥接文件" class="headerlink" title="桥接文件"></a>桥接文件</h2><p>导入成功后, 新建一个Header File文件进行桥接<br><img src="/images/Swift_SQLite_images/QQ20160414-6@2x.png" alt="QQ20160414-6@2x.png"></p>
<p>如果没有提示, 就按图中头文件名手动敲入<br><img src="/images/Swift_SQLite_images/QQ20160414-7@2x.png" alt="QQ20160414-7@2x.png"></p>
<p>打开Build Settings, 输入bri关键字进行搜索, 找到图中我选中的 <code>Objective-C Bridging Header</code> 这一行, 点击此行右边空白的地方, 弹出输入框, 从左边的文件栏选中文件你的桥接文件拽入输入框, 然后删除前面多余的路径地址<br><img src="/images/Swift_SQLite_images/QQ20160414-8@2x.png" alt="QQ20160414-8@2x.png"></p>
<p>然后编译一下, 成功就表示路径地址设置对了<br><img src="/images/Swift_SQLite_images/QQ20160414-9@2x.png" alt="QQ20160414-9@2x.png"></p>
<p>随便回到哪个控制器, 能够敲出sqlite的方法, 并且编译成功, 就表示导入成功了<br><img src="/images/Swift_SQLite_images/QQ20160414-10@2x.png" alt="QQ20160414-10@2x.png"></p>
<hr>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点:"></a>注意点:</h2><p>移除sqlite库文件的时候, 千万不要选择移除到废纸篓, 不然不小心清空废纸篓了, 那么你的库文件也被删掉了, 点击图中箭头指示的移除引用即可<br><img src="/images/Swift_SQLite_images/QQ20160414-11@2x.png" alt="QQ20160414-11@2x.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;注: 图中所用的Xcode版本为Xcode7.3&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;导入库&quot;&gt;&lt;a href=&quot;#导入库&quot; class=&quot;headerlink&quot; title=&quot;导入库&quot;&gt;&lt;/a&gt;导入库&lt;/h2&gt;&lt;p&gt;按下图顺序进行导入SQLite库&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://zedxpp.com/categories/Swift/"/>
    
    
      <category term="SQLite" scheme="http://zedxpp.com/tags/SQLite/"/>
    
      <category term="Swift" scheme="http://zedxpp.com/tags/Swift/"/>
    
  </entry>
  
</feed>
