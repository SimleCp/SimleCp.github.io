<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[为你的hexo博客配置个性域名]]></title>
      <url>%2F2017%2F03%2F05%2F%E4%B8%BA%E4%BD%A0%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%B8%AA%E6%80%A7%E5%9F%9F%E5%90%8D%2F</url>
      <content type="text"><![CDATA[前言文章以阿里云的.com域名为例子, 你也可以购买其他后缀的域名. 购买1.打开阿里云https://wanwang.aliyun.com/, 输入你想搜索的域名, 点击查域名. 2.选好域名, 域名的后缀, 加入清单, 确认信息, 然后去结算. 3.确定域名, 年限, 持有者为个人, 创建信息模板. 立即购买. 4.结算完成后, 点击右上角的控制台, 为域名进行解析. 解析1.点击域名, 域名列表, 找到域名进行解析. 2.添加3条解析记录.初次解析可能会有点慢. 记录类型, 主机记录, 记录值, 是需要我们填写的, 其他的不要管. 按我下面的指示填写, 除了pengpengtest.github.io中的pengpengtest需要换成你的github用户名, 其他的照着填. 1234记录类型 主机记录 记录值CNAME www 你的github用户名.github.ioA @ 192.30.252.153A @ 192.30.252.154 本地配置1.先进入桌面, cd 你的hexo本地目录, cd source, touch CNAME创建CNAME文件, open CNAME打开并编辑. 2.填入域名, 不用加任何http://或者www, 填写完成后保存退出. 3.输入../回到你的hexo本地目录. hexo g -d重新生成部署. 4.然后访问域名, 比如我的, swift520.com, 成功!~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片并茂教你搭建hexo博客,部署github,更换主题]]></title>
      <url>%2F2017%2F03%2F05%2F%E5%9B%BE%E7%89%87%E5%B9%B6%E8%8C%82%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%2C%E9%83%A8%E7%BD%B2github%2C%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%2F</url>
      <content type="text"><![CDATA[必备环境 Git(安装了Xcode就会自带, 所以不再赘述) Node.js可以用很多种方式安装Node.js, 但是为了必免因缺少各种环境而安装失败, 这里推荐直接下载安装包安装.https://nodejs.org/zh-cn/download/ Hexo 打开终端, 输入npm install -g hexo-cli进行安装. 搭建本地HexoHexo只是帮你生成静态网页博客的工具, 你可以在本地进行调试. 如果你想让别人也能看到. 你必须上传到github或者自己的vps服务器. 别急, 接下来我都会为你讲解如何操作. 1.为了测试方便, 我把我的本地环境搭建在桌面的某个文件夹. 你也可以存放到你想存放的文件夹去. 注: 如果你想存放到别的地方, 那么你需要打开想存放的地方, 并且cd进去, 拖拽目标文件夹到终端, 既可获取目标路径, 拷贝路径, 然后cd进去既可. 2.打开终端, 输入cd Desktop到桌面. 3.我准备把环境搭建在桌面的peng文件夹中, 所以我继续在终端输入mkdir peng创建名叫peng的文件夹. 4.cd peng进入叫peng的文件夹中. 5.输入hexo init进行初始化. 6.输入npm install进行安装, 过一会儿会卡在&gt; node scripts/install.js这里, 你继续等待既可, 当出现如下图片, 安装成功. 7.输入npm install hexo-deployer-git --save安装简化命令的插件. 8.输入hexo s, 并且拷贝地址http://0.0.0.0:4000/到浏览器, 进行本地预览. 9.对, 就是这么简单, 本地环境搭建成功. 按control + c退出预览.不要关掉终端, 待会所有的操作, 都要在这个叫peng的文件夹中操作 10.接下来我们需要让本地环境生成静态网页, 并且上传到github中. 部署博客到github pages1.打开github.com并且登录你的账号, 账号必须已经通过了邮箱认证点击 Verify email address 链接验证邮箱, 否则可能导致部署失败出现404. 在你注册账号的时候, github就会发送邮件到你的邮箱. 2.登录账号后, 点击右上角的github头像, 点击Your profile. 3.然后将浏览器地址栏,红框框起来的github用户名记录下来. 4.点击右上角的+号按钮, 创建新的仓库. 5.仓库名必须是你的用户名.github.io组成, 其他的都可以不用管, 填完仓库名后, 直接Create repository既可. 6.点击按钮复制并且记录仓库地址, 待会要用到. 7.在终端输入open _config.yml, 打开hexo配置文件, 滑动到最下面, 找到deploy, repository和branch这两个默认没有, 你按我的格式粘贴既可. type后面写git, repository后面是你刚刚复制并记录的仓库地址, branch直接写master既可, 然后保存并关闭 1234deploy: type: git repository: https://github.com/pengpengtest/pengpengtest.github.io.git branch: master 8.输入hexo g -d, 重新生成并部署网页到github仓库.期间会让你输入账号和密码.账号和密码每输入完一项回车既可.密码是不会显式出现的. 9.出现下图,表示部署博客到github仓库成功.打开github仓库, 里面已经有了文件了. 10.接下来在浏览器输入你的用户名.github.io打开.博客已成功部署到github仓库!别人也可以通过这个地址你的用户名.github.io来访问你的博客了! 发布新文章1.在终端输入hexo n &quot;文章名&quot;, 创建文章.并且用open xxxxx打开它. 写入文章内容. 2.分别输入hexo g(生成)和hexo d(部署)后, 或者直接hexo g -d后, 再打开你的用户名.github.io. 新的文章也发布成功了.(有时候可能需要清除一下浏览器缓存才行) 分别输入hexo g和hexo d等效于hexo g -d. 更换hexo主题1.在搜索引擎搜索 hexo theme 既可. 2.在这里, 我们用iissnan/hexo-theme-next主题来演示.首先进入你想用的主题github仓库, 拷贝仓库地址. 3.在终端输入git clone 主题仓库地址 theme/主题名字.接下来一顿下载. git clone https://github.com/iissnan/hexo-theme-next.git themes/iissnan 4.下载完成后, 输入open _config.yml找到theme,修改hexo配置, 告诉hexo你想用的主题名字. 5.接下来hexo clean清理缓存, hexo g -d重新生成博客并且部署. 打开你的用户名.github.io, 更换主题成功!(有时候可能需要清除一下浏览器缓存才行, 浏览器缓存就是这么麻烦, 你懂的) 6.以后想更换主题, 按这个步骤来就行了.清理缓存并不会删除你的文章, 可以放心操作. 用github当图床如果需要用github当图床, 可以把图片放到本地hexo目录/source/文件夹里面, 我是新建了一个images来存放的. 需要先部署和生成, 把图片放到github上, 才能通过链接找到. 如果是直接放在source目录下, 那么你的图片链接地址就是http://域名/图片名.图片后缀. 比如:http://cxp.im/favicon.ico这个小图标, 我是做了https转发, 所以实际浏览器上显示的链接不一样(你可以直接拷贝我给的链接查看) 如果是放在二级目录下, 就需要加上目录名称, 比如我放在images下的这个头像, 那么就是http://cxp.im/images/icon.jpg 科普时间 重点: 所有hexo xxx的操作, 必须用终端cd 你本地环境目录下, 然后才能用hexo xxx操作. 有时候明明已经新建, 修改了文章, 或者改变了博客或主题的各种配置, 并且生成部署了, 还是不能显示, 可能是github还没缓存好, 稍微等半分钟的样子, 再看看. 不行就清理浏览器缓存. 还是不行, 就hexo clean清理本地缓存. 再重新生成和部署. hexo本地环境介绍 123_config.yml 用来存放hexo博客的个人描述, 博客小图标地址, 头像地址等等.source下的_posts 存放你所有的博文.md文件 你可以通过 hexo n "xxx" 创建博客文章, 也可以直接把xxx.md 格式的文件直接拖入进去themes 存放你的所有主题文件 各种hexo xxx操作1234hexo clean 清理缓存, 一般是在配置不能生效, 或者文章发布了不显示, 等等异常情况下使用的. 当然有时候清除浏览器缓存也是必须的操作.hexo g 重新生成静态网页, 所有发布文章, 修改文章, 修改hexo配置, 修改主题配置等等操作, 都需要.hexo d 让你的静态网页从本地部署到githubhexo s 你可以边写文章, 边使用这个命令在本地预览, 包括修改各种配置, 都可以预览. 必备语法和工具 使用hexo博客, 你需要会markdown语法, 才能编写更漂亮排版的文章.自行搜索markdown 语法关键字查找. 并且你需要一个能识别并编写markdown语法的编辑器. 自行搜索markdown 编辑器关键字查找. 各种免费的, 收费的.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用VPS搭建科学上网工具和个人博客(教程合集)]]></title>
      <url>%2F2017%2F02%2F25%2F%E5%88%A9%E7%94%A8VPS%E6%90%AD%E5%BB%BA%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E6%95%99%E7%A8%8B%E5%90%88%E9%9B%86)%2F</url>
      <content type="text"><![CDATA[前言从教程中, 你可以收获什么? 如何购买搬瓦工vps 如何使用搬瓦工vps后台 如何搭建Shadowsocks Sever来实现多终端翻墙. 如何搭建个人hexo博客, 如何用github当博客图床, 更换hexo主题 如何为博客配置个性域名 如何使用vps存放个人博客 如何使用vps当图床 如何为博客配置https 以上内容都是我全部亲测过, 中横线部分, 会在下来的日子更新, 请持续关注. 搭建一个翻墙工具, 上google找文章, 存放个人博客, 把vps当图床, 都还是比较值得的.毕竟入门款的vps, 算上优惠码, 一年也仅仅只需要19美刀左右. 文章收集了从购买vps, 搭建Shadowsocks, 搭建Ipsec等一系列文章. 并结合自己使用时碰到的问题, 一一分享给大家. 文章内容, 假设阅读者是没有任何购买和搭建vps的经验, 所以会尽量讲解的比较仔细. 文章内容均以搬瓦工vps来讲解. 以下购买和登录后台的教程来自http://banwagong.cn/, 实际操作均在搬瓦工官网. 环境vps: 搬瓦工工具: Mac终端 购买和使用注: 搬瓦工vps支付方式支持 PayPal AliPay Credit Card(Stripe) 搬瓦工官网 搬瓦工购买方案 图文并茂购买指导教程 注: 购买时长分月付, 季度付, 半年付, 年付 选择登录已购VPS方案面板 注: 不知道你自己的服务器ip和密码, 用此方式登录已知你的服务器ip和密码, 可以直接进入搬瓦工面板登录 教程中的vps系统都是centos-6-x86的.请安装一致. 自主任意更换机房实现换IP (无此需求可略过) 重新安装Linux系统过程及注意事项 (无此需求可略过) 注: 切换机房ip和重装系统, 请先stop服务器 插曲建议大家购买搬瓦工vps后, 从官网的已购列表进入kiwivm面板, 记录自己的ip地址, 并更改kiwivm面板的密码. 避免每次进入kiwivm面板都要从官网操作好几步才能进. kiwivm搬瓦工面板登录入口 ip地址查看(教程中的ip地址都是这个) 修改kiwivm面板密码 一键搭建Shadowsocks下载Shadowsocks可以在Windows/Mac/iPhone系统上使用. windows下载地址 mac下载地址 iphoneApp下载地址 安装Shadowsocks Sever 在左边部分菜单栏滑动到底部, 点击shadowsocks sever之后, 如果没有安装过shadowsocks sever, 就需要点击install来一键安装shadowsocks sever. 请记录页面上的port和password.后面设置会用到. Windows/Mac/iPhone上的shadowsocks软件设置都差不多, 所以这里只讲一种, 以mac为例 为方便讲解, 后面会统一叫Shadowsocks为小飞机! 配置Shadowsocks软件下载并打开软件后在状态栏找到软件, 对! 就是一个飞机的样子=. = 红色框住的部分是我们可能会使用到. 自动代理模式: 需要翻墙的会自动翻墙, 不需要的就不翻墙. 全局模式: 所有的都会翻墙. 服务器: 选择, 增加, 减少, 编辑服务器设定. 编辑自动模式的PAC: 如果你需要指定某个网站强制翻墙, 那么你需要点击它, 并且编辑gfwlist.js文件, 照着葫芦画瓢, 加上网站地址既可, 如果用mac自带的文本编辑来编辑文件, 请务必注意双引号的区别!!!否则可能导致无法使用小飞机. 生成二维码和扫描二维码: 在iPhone上或者mac上, 为了快速的分享你的小飞机的服务器配置, 可能会使用到. 扫描一下生成的二维码, 既可添加配置. 不用你在多设备的时候输入N遍. 帮助: 当你想下载最新的小飞机版本, 或者找不到小飞机下载地址, 可以点它. 在图中填入服务器ip地址, 填入刚刚在shadowsocks sever中的prot端口号和密码, 加密方式不动它. 备注随便填~然后点击确定既可.接下来就是打开浏览器, 输入google.com来测试你的成果~ iPhone/iPad实现VPN翻墙, 有两种方式. 一种是使用Wingy - Http(s),Socks5 Proxy Utility这个app软件+之前配置的Shadowsocks Sever来实现, 并且软件支持Widget一键翻墙. 一种是需要在vps服务器安装ipsec, 稍微比较麻烦点. 并且需要在设置-&gt;通用-&gt;VPN中配置一次. 但是不需要下载任何软件. 以后使用, 直接打开设置&gt;打开VPN既可.(我个人是比较喜欢这种方式, 不想安装软件) 如果你选择了第二种方式, 那么, 请接着往下看. 在VPS上配置iPsec以下内容均来自https://quericy.me/blog/699/, 我只是在他的教程基础上进行了重新整理, 并补充了一些说明, 让你更快的配置iPsec, 所以你直接按照我的步骤来既可. 接下来会使用vim编辑内容, 如果你不会vim, 那么请点开查看vim的简单使用.如果你会vim的使用, 那么请继续往下看. 1.打开root shell - interactive, 点击launch 2.界面会跳转并变大变小几次来进行加载, 然后输入passwd, 修改服务器密码, 服务器密码和kiwivm后台是两个互不干扰的密码, 但是建议改成一样.输入新密码, 回车, 再次输入, 回车, 出现下图最后一句话, 表示密码修改成功. 3.打开kiwivm首页, 找到ip地址和ssh port端口地址并记录下来 4.打开mac终端, 输入ssh root@你的ip地址 -p SSH Port端口号如: ssh root@192.192.192.192 -p 28400 5.会提示你输入密码, 输入刚刚修改的服务器密码.出现[root@localhost ~]#表示连接成功. 6.输入 wget --no-check-certificate https://raw.githubusercontent.com/quericy/one-key-ikev2-vpn/master/one-key-ikev2.sh7.等进度走完了, 继续输入chmod +x one-key-ikev2.sh8.输入bash one-key-ikev2.sh9.出现这个时, 请输入2并回车 10.接下来只要有停顿, 也是直接回车既可.11.当出现install complete, 说明安装成功了. 12.打开sysctl文件, 输入vim /etc/sysctl.conf修改net.ipv4.ip_forward = 1, 把0改成1找到以下四个, 分别在每句最前面加上#把当前行注释掉. 1234net.bridge.bridge-nf-call-ip6tablesnet.bridge.bridge-nf-call-iptablesnet.bridge.bridge-nf-call-arptablesnet.nf_conntrack_max 如: #net.bridge.bridge-nf-call-ip6tables...... 13.使用以下指令刷新sysctl, 输入：sysctl -p 14.输入vim /usr/local/etc/ipsec.secrets并编辑, 编辑完后保存并退出编辑. 账号格式: 账号 %any : EAP &quot;密码&quot;, 密码用&quot;&quot;双引号包起来, 如果你只需要一个, 就添加一个, 如果需要多个, 换行添加. 12345: RSA server.pem: PSK "myPSKkey": XAUTH "myXAUTHPass"peng %any : EAP "123456"peng2 %any : EAP "123456" 15.输入ipsec start启动ipsec 1234567ipsec常用指令ipsec start #启动服务ipsec stop #关闭服务ipsec restart #重启服务ipsec reload #重新读取ipsec status #查看状态ipsec --help #查看帮助 16.服务器重启后, ipsec是不会自动启动的, 所以我们需要把它添加到自启动.在终端输入vim /etc/rc.local,添加/usr/local/sbin/ipsec start 添加后如图: 17.然后打开手机, 设置-&gt;通用-&gt;VPN-&gt;添加VPN配置 下图中的PSK是有用的 18.点击完成后, 回到VPN页面点连接既可. 19.如果你的手机上没有装任何小飞机的软件, 你后续使用, 就直接点这个就可以了.否则你需要进到 设置-&gt;通用-&gt;VPN-&gt;连接. 未完待续, 请关注我!~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vim的简单使用]]></title>
      <url>%2F2017%2F02%2F25%2FVim%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[为配合教程, 所以简单的介绍下vim的基础使用. 当你在终端输入vi xxx或者vim xxx的后.会进入下图的状态, 请多注意左下角, 每一个步骤左下角都会有变化. 1.未编辑状态 2.按键盘上的i进入编辑状态, 然后输入内容输入前输入后 3.按esc退出编辑状态 4.输入:wq保存并退出 5.保存并退出后]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Quartz2D]]></title>
      <url>%2F2016%2F05%2F08%2FQuartz2D%2F</url>
      <content type="text"><![CDATA[Quartz2D简介 Quartz 2D是一个二维图形绘制引擎，支持iOS环境和Mac OS X环境。 Quartz 2D以PDF的规范为基础的图形库，用来绘制二维文字和图形，允许相同的绘图指令在任何装置上，使用可以得到的最佳分辨率，产生相同的输出。 Quartz 2D API可以实现许多功能，如基于路径的绘图、透明度、阴影、颜色管理、反锯齿、PDF文档生成和PDF元数据访问等。 Quartz 2D API是Core Graphics框架的一部分，因此其中的很多数据类型和方法都是以CG开头的。会经常见到Quartz 2D（Quartz）和Core Graphics两个术语交互使用。 Quartz 2D与分辨率和设备无关，因此在使用Quartz 2D绘图时，无需考虑最终绘图的目标设备。 注:本文内容均来自, 我自己学习过程中的整理, Quartz2D介绍部分来自 Rynn的博客 具体更详细的Quartz2D介绍可以点击链接查看, 本博文主要以实战代码为主. 学习Quartz2D必须了解的方法 - (void)drawRect:(CGRect)rect123- (void)drawRect:(CGRect)rect &#123; // Drawing code&#125; 对View进行绘制, 必须在这个方法内进行codeing. 因为只有在这个方法中才能获取到跟View相关联的上下文.(系统内部会创建好上下文, 我们只需要直接get获取就好) 当View即将显示的时候, 会自动调用这个方法. - (void)drawRect:(CGRect)rect 中的rect参数, 可以获取到当前View的CGRect 准备 新建项目, 在项目里面创建一个UIView. 自定义一个继承UIView的类, 并且让创建出来的UIView的类型, 继承自你刚刚自定义的那个类. 接下来我们就可以在刚刚自定义的类, - (void)drawRect:(CGRect)rect的方法中愉快的玩耍了. 一般新建一个继承自UIView的类, 在.m中会自动帮我们生成好- (void)drawRect:(CGRect)rect方法, 我们只需要打开就好. 12345678910111213#import "DrawView.h"@implementation DrawView/*// Only override drawRect: if you perform custom drawing.// An empty implementation adversely affects performance during animation.- (void)drawRect:(CGRect)rect &#123; // Drawing code&#125;*/@end 画线画一条直线12345678910111213141516171819- (void)drawRect:(CGRect)rect &#123; // 获取图形上下文(在 drawRect: 方法中, 系统已经帮我们创建好了图形上下文) CGContextRef ctx = UIGraphicsGetCurrentContext(); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPath]; // 设置起点 [path moveToPoint:CGPointMake(50, 100)]; // 添加一条线到某个点 [path addLineToPoint:CGPointMake(200, 200)]; // 添加路径到图形上下文 CGContextAddPath(ctx, path.CGPath); // 绘制 CGContextStrokePath(ctx);&#125; 两点成一线, 所以我们设置起点, 设置终点, 就可以画线 CGContextAddPath(ctx, path.CGPath); 因为这个函数需要接收的参数是CGPathRef, 而我们创建的并不是, 所以我们需要调用UIBezierPath类的- (CGPathRef)CGPath方法, 把 UIBezierPath类型转换成CGPathRef. 画两条直线 想要实现画两条或多条直线的方法, 有两种方式. 第一种 12345678910111213141516171819202122232425- (void)drawRect:(CGRect)rect &#123; // 获取图形上下文(在 drawRect: 方法中, 系统已经帮我们创建好了图形上下文) CGContextRef ctx = UIGraphicsGetCurrentContext(); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPath]; // 设置起点 [path moveToPoint:CGPointMake(50, 100)]; // 设置终点 [path addLineToPoint:CGPointMake(200, 200)]; // 一个路径对象可以包含很多线段, 所以我们可以继续设置起点 [path moveToPoint:CGPointMake(50, 200)]; // 设置终点 [path addLineToPoint:CGPointMake(100, 200)]; // 添加路径到图形上下文 CGContextAddPath(ctx, path.CGPath); // 绘制 CGContextStrokePath(ctx);&#125; 第二种 1234567891011121314151617181920212223242526272829303132- (void)drawRect:(CGRect)rect &#123; // 获取图形上下文(在 drawRect: 方法中, 系统已经帮我们创建好了图形上下文) CGContextRef ctx = UIGraphicsGetCurrentContext(); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPath]; // 设置起点 [path moveToPoint:CGPointMake(200, 100)]; // 设置终点 [path addLineToPoint:CGPointMake(200, 200)]; // 添加路径到图形上下文 CGContextAddPath(ctx, path.CGPath); // 因为上一个路径已经添加到了图形上下文中了, 所以我们可以重新创建一个UIBezierPath对象, // 来改变path的指针指向. path = [UIBezierPath bezierPath]; // 设置起点,移动到某个位置 [path moveToPoint:CGPointMake(30, 200)]; // 设置终点 [path addLineToPoint:CGPointMake(100, 200)]; // 添加路径到图形上下文 CGContextAddPath(ctx, path.CGPath); // 绘制 CGContextStrokePath(ctx);&#125; 对比完两种方法, 第二种方法比第一种方法多了几个步骤, 1.重新创建新的路径 2.设置起点, 终点 3.添加路径到上下文. 从实用角度来讲, 我个人更倾向于第二种, 自己的路径, 自己的路径对象进行管理, 从代码行数角度来讲, 当然是第一种好. 上面所讲的方法是用来绘制平行或无连接关系的线段. 画有 连接关系 的线段和设置线段的属性1234567891011121314151617181920212223242526272829303132- (void)drawRect:(CGRect)rect &#123; // 获取图形上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPath]; // 设置起点 [path moveToPoint:CGPointMake(30, 100)]; // 设置终点 [path addLineToPoint:CGPointMake(200, 200)]; // 设置第二根线的终点 [path addLineToPoint:CGPointMake(100, 100)]; // 添加路径到图形上下文 CGContextAddPath(ctx, path.CGPath); // 设置线宽 CGContextSetLineWidth(ctx, 10); // 设置线条两端的样式为圆角 CGContextSetLineCap(ctx, kCGLineCapRound); // 设置线条连接处的样式为圆角 CGContextSetLineJoin(ctx, kCGLineJoinRound); // 绘制 CGContextStrokePath(ctx);&#125; 如果画的线段是连接在一起的, 可以直接设置第二根线的终点, 不必重现设置起点. 设置线条两端的样式和连接处的样式的参数是枚举, 剩下的样式请自行尝试. UIBezierPath 因为UIBezierPath类里面已经帮我们封装好了很多东西, 所以绘制线段有更快捷的方法. 1234567891011- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:CGPointMake(50, 50)]; [path addLineToPoint:CGPointMake(200, 200)]; [path stroke]; &#125; 总结123456789绘制步骤可以分成四个大的步骤1. 获取当前View的图形上下文2. 创建路径 2.1 设置起点 2.2 设置终点 2.3 ....3. 添加路径到图形上下文4. 绘制 绘制基本图形矩形和正方形正方形123456- (void)drawRect:(CGRect)rect &#123; // 第一个参数表示需要绘制图形的frame, 第二个参数表示半径(可以通过修改这个参数来达到绘制带圆角的图形和绘制圆形) UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 50, 160, 160) cornerRadius:0]; [path stroke];&#125; 圆角矩形123456- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 50, 160, 100) cornerRadius:20]; [path stroke];&#125; 圆型123456- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 50, 150, 150) cornerRadius:75]; [path stroke];&#125; 这里只放置3种样式的代码, 其他样式可以修改参数, 通过这个方法来绘制正方形, 矩形, 圆角正方形, 圆角矩形, 圆形,等… 椭圆1234- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(30, 30, 200, 100)]; [path stroke];&#125; 用以上方法同样也可以绘制圆形 圆弧123456789101112131415- (void)drawRect:(CGRect)rect &#123; // 获取当前控件的圆心 CGPoint center = CGPointMake(rect.size.width * 0.5, rect.size.height * 0.5); // 获取半径 CGFloat radius = rect.size.width * 0.5 * 0.5; /* 参数一 需要绘制圆弧的圆心在哪, 参数二 圆弧到圆心的半径, 参数三 圆弧开始角度, 参数四 圆弧结束角度, 参数五 传入YES表示顺时针, 传入NO表示逆时针 */ UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:0 endAngle:M_PI clockwise:YES]; [path stroke];&#125; 从以上图片可以看出, 开始角度并不是从12点钟方向开始的, 而是从3点钟方向开始的. 所以在绘制圆弧的时候需要注意, 如果需要从12点钟方向开始, 那么开始角度应该是-90度开始 在OC中, 已经定义好了一些常用的宏, M_PI表示180°, M_PI_2表示90°, M_PI_4表示45°.(具体可以跳到头文件进行查看) 具体角度与弧度互转, 引用至百度知道的答案 弧度 ＝ (角度 / 180) PIPI就是“派”比如180度角，转换之后的弧度就是PI，45度的话是四分之一PI。反过来也一样，角度 = 弧度 / PI 180 扇形123456789101112131415161718- (void)drawRect:(CGRect)rect &#123; // 获取圆心 CGPoint center = CGPointMake(rect.size.width * 0.5, rect.size.height * 0.5); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:100 startAngle:0 endAngle:M_PI_2 clockwise:YES]; // 添加一根线到圆心 [path addLineToPoint:center]; // 从圆心添加线到圆弧的起始点 // [path addLineToPoint:CGPointMake(center.x + 100, center.y)]; // 关闭路径 [path closePath]; // 绘制 [path stroke];&#125; 从上述代码可以看出, 绘制扇形, 其实就是先绘制圆弧, 然后添加一根线到圆心, 再添加一根线到圆弧的起始点位置, 就组成了一个扇形. UIBezierPath类为我们提供了更加便捷的方法, 所以在添加第二根线, 圆心到圆弧起始点位置, 我们可以直接调用[path closePath]的对象方法, 这样也减少了位置的计算. 扇形的描边和填充修改描边颜色123456789101112- (void)drawRect:(CGRect)rect &#123; // 此处省略创建路径等代码, 重点讲解如何描边 // 关闭路径 [path closePath]; // 设置描边颜色 [[UIColor greenColor] setStroke]; // 绘制 [path stroke];&#125; 在关闭路径后, 绘制之前, 如果我们需要设置扇形的线条颜色, 可以通过setStroke方法来设置颜色. 填充123456789101112131415- (void)drawRect:(CGRect)rect &#123; // 获取圆心 CGPoint center = CGPointMake(rect.size.width * 0.5, rect.size.height * 0.5); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:100 startAngle:0 endAngle:M_PI_2 clockwise:YES]; // 添加一根线到圆心 [path addLineToPoint:center]; // 设置填充颜色 [[UIColor blueColor] setFill]; // 填充 [path fill];&#125; 如果你是需要填充扇形, 那么可以省略关闭路径这一步骤closePath 并且不再是调用stroke方法, 而是调用fill方法 同时填充和描边 如果你需要同时填充和描边扇形, 那么UIBezierPath并没有帮我们封装类似的方法, 所以我们还是需要使用CoreGraphics框架中的C语言函数来实现. 12345678910111213141516171819202122232425262728293031- (void)drawRect:(CGRect)rect &#123; // 获取圆心 CGPoint center = CGPointMake(rect.size.width * 0.5, rect.size.height * 0.5); // 获取上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:100 startAngle:0 endAngle:M_PI_2 clockwise:YES]; // 添加一根线到圆心 [path addLineToPoint:center]; // 关闭路径 [path closePath]; // 把路径添加到上下文 CGContextAddPath(ctx, path.CGPath); // 设置填充颜色 [[UIColor blueColor] setFill]; // 设置描边颜色 [[UIColor greenColor] setStroke]; // 设置线宽 CGContextSetLineWidth(ctx, 5); // 渲染 (第二个形参表示绘画模式是填充和描边都需要, 这个参数是枚举) CGContextDrawPath(ctx, kCGPathFillStroke);&#125; 这里是需要关闭路径的, 不关闭会有问题. 你可以试试注释掉关闭路径的代码.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift导入SQLite库, Swift桥接OC 步骤]]></title>
      <url>%2F2016%2F04%2F14%2FSwift%E5%AF%BC%E5%85%A5SQLite%E5%BA%93%2C%20Swift%E6%A1%A5%E6%8E%A5OC%20%E6%AD%A5%E9%AA%A4%2F</url>
      <content type="text"><![CDATA[注: 图中所用的Xcode版本为Xcode7.3 导入库按下图顺序进行导入SQLite库 桥接文件导入成功后, 新建一个Header File文件进行桥接 如果没有提示, 就按图中头文件名手动敲入 打开Build Settings, 输入bri关键字进行搜索, 找到图中我选中的 Objective-C Bridging Header 这一行, 点击此行右边空白的地方, 弹出输入框, 从左边的文件栏选中文件你的桥接文件拽入输入框, 然后删除前面多余的路径地址 然后编译一下, 成功就表示路径地址设置对了 随便回到哪个控制器, 能够敲出sqlite的方法, 并且编译成功, 就表示导入成功了 注意点:移除sqlite库文件的时候, 千万不要选择移除到废纸篓, 不然不小心清空废纸篓了, 那么你的库文件也被删掉了, 点击图中箭头指示的移除引用即可]]></content>
    </entry>

    
  
  
</search>
