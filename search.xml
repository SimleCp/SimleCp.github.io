<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[利用VPS搭建科学上网工具和个人博客(教程合集)]]></title>
      <url>%2F2017%2F02%2F25%2F%E5%88%A9%E7%94%A8VPS%E6%90%AD%E5%BB%BA%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E6%95%99%E7%A8%8B%E5%90%88%E9%9B%86)%2F</url>
      <content type="text"><![CDATA[前言从教程中, 你可以收获什么? 如何购买搬瓦工vps 如何使用搬瓦工vps后台 如何搭建Shadowsocks Sever来实现多终端翻墙. 如何搭建个人博客(hexo) 如何为博客配置域名 如何使用vps存放个人博客 如何使用vps当图床 如何为博客配置https 以上内容都是我全部亲测过, 中横线部分, 会在下来的日子更新, 请持续关注. 搭建一个翻墙工具, 上google找文章, 存放个人博客, 把vps当图床, 都还是比较值得的.毕竟入门款的vps, 算上优惠码, 一年也仅仅只需要19美刀左右. 文章收集了从购买vps, 搭建Shadowsocks, 搭建Ipsec等一系列文章. 并结合自己使用时碰到的问题, 一一分享给大家. 文章内容, 假设阅读者是没有任何购买和搭建vps的经验, 所以会尽量讲解的比较仔细. 文章内容均以搬瓦工vps来讲解. 以下购买和登录后台的教程来自http://banwagong.cn/, 实际操作均在搬瓦工官网. 环境vps: 搬瓦工工具: Mac终端 购买和使用注: 搬瓦工vps支付方式支持 PayPal AliPay Credit Card(Stripe) 搬瓦工官网 搬瓦工购买方案 图文并茂购买指导教程 注: 购买时长分月付, 季度付, 半年付, 年付 选择登录已购VPS方案面板 注: 不知道你自己的服务器ip和密码, 用此方式登录已知你的服务器ip和密码, 可以直接进入搬瓦工面板登录 教程中的vps系统都是centos-6-x86的.请安装一致. 自主任意更换机房实现换IP (无此需求可略过) 重新安装Linux系统过程及注意事项 (无此需求可略过) 注: 切换机房ip和重装系统, 请先stop服务器 插曲建议大家购买搬瓦工vps后, 从官网的已购列表进入kiwivm面板, 记录自己的ip地址, 并更改kiwivm面板的密码. 避免每次进入kiwivm面板都要从官网操作好几步才能进. kiwivm搬瓦工面板登录入口 ip地址查看(教程中的ip地址都是这个) 修改kiwivm面板密码 一键搭建Shadowsocks下载Shadowsocks可以在Windows/Mac/iPhone系统上使用. windows下载地址 mac下载地址 iphoneApp下载地址 安装Shadowsocks Sever 在左边部分菜单栏滑动到底部, 点击shadowsocks sever之后, 如果没有安装过shadowsocks sever, 就需要点击install来一键安装shadowsocks sever. 请记录页面上的port和password.后面设置会用到. Windows/Mac/iPhone上的shadowsocks软件设置都差不多, 所以这里只讲一种, 以mac为例 为方便讲解, 后面会统一叫Shadowsocks为小飞机! 配置Shadowsocks软件下载并打开软件后在状态栏找到软件, 对! 就是一个飞机的样子=. = 红色框住的部分是我们可能会使用到. 自动代理模式: 需要翻墙的会自动翻墙, 不需要的就不翻墙. 全局模式: 所有的都会翻墙. 服务器: 选择, 增加, 减少, 编辑服务器设定. 编辑自动模式的PAC: 如果你需要指定某个网站强制翻墙, 那么你需要点击它, 并且编辑gfwlist.js文件, 照着葫芦画瓢, 加上网站地址既可, 如果用mac自带的文本编辑来编辑文件, 请务必注意双引号的区别!!!否则可能导致无法使用小飞机. 生成二维码和扫描二维码: 在iPhone上或者mac上, 为了快速的分享你的小飞机的服务器配置, 可能会使用到. 扫描一下生成的二维码, 既可添加配置. 不用你在多设备的时候输入N遍. 帮助: 当你想下载最新的小飞机版本, 或者找不到小飞机下载地址, 可以点它. 在图中填入服务器ip地址, 填入刚刚在shadowsocks sever中的prot端口号和密码, 加密方式不动它. 备注随便填~然后点击确定既可.接下来就是打开浏览器, 输入google.com来测试你的成果~ iPhone/iPad实现VPN翻墙, 有两种方式. 一种是使用Wingy - Http(s),Socks5 Proxy Utility这个app软件+之前配置的Shadowsocks Sever来实现, 并且软件支持Widget一键翻墙. 一种是需要在vps服务器安装ipsec, 稍微比较麻烦点. 并且需要在设置-&gt;通用-&gt;VPN中配置一次. 但是不需要下载任何软件. 以后使用, 直接打开设置&gt;打开VPN既可.(我个人是比较喜欢这种方式, 不想安装软件) 如果你选择了第二种方式, 那么, 请接着往下看. 在VPS上配置iPsec以下内容均来自https://quericy.me/blog/699/, 我只是在他的教程基础上进行了重新整理, 并补充了一些说明, 让你更快的配置iPsec, 所以你直接按照我的步骤来既可. 接下来会使用vim编辑内容, 如果你不会vim, 那么请点开查看vim的简单使用.如果你会vim的使用, 那么请继续往下看. 1.打开root shell - interactive, 点击launch 2.界面会跳转并变大变小几次来进行加载, 然后输入passwd, 修改服务器密码, 服务器密码和kiwivm后台是两个互不干扰的密码, 但是建议改成一样.输入新密码, 回车, 再次输入, 回车, 出现下图最后一句话, 表示密码修改成功. 3.打开kiwivm首页, 找到ip地址和ssh port端口地址并记录下来 4.打开mac终端, 输入ssh root@你的ip地址 -p SSH Port端口号如: ssh root@192.192.192.192 -p 28400 5.会提示你输入密码, 输入刚刚修改的服务器密码.出现[root@localhost ~]#表示连接成功. 6.输入 wget --no-check-certificate https://raw.githubusercontent.com/quericy/one-key-ikev2-vpn/master/one-key-ikev2.sh7.等进度走完了, 继续输入chmod +x one-key-ikev2.sh8.输入bash one-key-ikev2.sh9.出现这个时, 请输入2并回车 10.接下来只要有停顿, 也是直接回车既可.11.当出现install complete, 说明安装成功了. 12.打开sysctl文件, 输入vim /etc/sysctl.conf修改net.ipv4.ip_forward = 1, 把0改成1找到以下四个, 分别在每句最前面加上#把当前行注释掉. 1234net.bridge.bridge-nf-call-ip6tablesnet.bridge.bridge-nf-call-iptablesnet.bridge.bridge-nf-call-arptablesnet.nf_conntrack_max 如: #net.bridge.bridge-nf-call-ip6tables...... 13.使用以下指令刷新sysctl, 输入：sysctl -p 14.输入vim /usr/local/etc/ipsec.secrets并编辑, 编辑完后保存并退出编辑. 账号格式: 账号 %any : EAP &quot;密码&quot;, 密码用&quot;&quot;双引号包起来, 如果你只需要一个, 就添加一个, 如果需要多个, 换行添加. 12345: RSA server.pem: PSK "myPSKkey": XAUTH "myXAUTHPass"peng %any : EAP "123456"peng2 %any : EAP "123456" 15.输入ipsec start启动ipsec 1234567ipsec常用指令ipsec start #启动服务ipsec stop #关闭服务ipsec restart #重启服务ipsec reload #重新读取ipsec status #查看状态ipsec --help #查看帮助 16.服务器重启后, ipsec是不会自动启动的, 所以我们需要把它添加到自启动.在终端输入vim /etc/rc.local,添加/usr/local/sbin/ipsec start 添加后如图: 17.然后打开手机, 设置-&gt;通用-&gt;VPN-&gt;添加VPN配置 下图中的PSK是有用的 18.点击完成后, 回到VPN页面点连接既可. 19.如果你的手机上没有装任何小飞机的软件, 你后续使用, 就直接点这个就可以了.否则你需要进到 设置-&gt;通用-&gt;VPN-&gt;连接. 未完待续, 请关注我!~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vim的简单使用]]></title>
      <url>%2F2017%2F02%2F25%2FVim%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[为配合教程, 所以简单的介绍下vim的基础使用. 当你在终端输入vi xxx或者vim xxx的后.会进入下图的状态, 请多注意左下角, 每一个步骤左下角都会有变化. 1.未编辑状态 2.按键盘上的i进入编辑状态, 然后输入内容输入前输入后 3.按esc退出编辑状态 4.输入:wq保存并退出 5.保存并退出后]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Quartz2D]]></title>
      <url>%2F2016%2F05%2F08%2FQuartz2D%2F</url>
      <content type="text"><![CDATA[Quartz2D简介 Quartz 2D是一个二维图形绘制引擎，支持iOS环境和Mac OS X环境。 Quartz 2D以PDF的规范为基础的图形库，用来绘制二维文字和图形，允许相同的绘图指令在任何装置上，使用可以得到的最佳分辨率，产生相同的输出。 Quartz 2D API可以实现许多功能，如基于路径的绘图、透明度、阴影、颜色管理、反锯齿、PDF文档生成和PDF元数据访问等。 Quartz 2D API是Core Graphics框架的一部分，因此其中的很多数据类型和方法都是以CG开头的。会经常见到Quartz 2D（Quartz）和Core Graphics两个术语交互使用。 Quartz 2D与分辨率和设备无关，因此在使用Quartz 2D绘图时，无需考虑最终绘图的目标设备。 注:本文内容均来自, 我自己学习过程中的整理, Quartz2D介绍部分来自 Rynn的博客 具体更详细的Quartz2D介绍可以点击链接查看, 本博文主要以实战代码为主. 学习Quartz2D必须了解的方法 - (void)drawRect:(CGRect)rect123- (void)drawRect:(CGRect)rect &#123; // Drawing code&#125; 对View进行绘制, 必须在这个方法内进行codeing. 因为只有在这个方法中才能获取到跟View相关联的上下文.(系统内部会创建好上下文, 我们只需要直接get获取就好) 当View即将显示的时候, 会自动调用这个方法. - (void)drawRect:(CGRect)rect 中的rect参数, 可以获取到当前View的CGRect 准备 新建项目, 在项目里面创建一个UIView. 自定义一个继承UIView的类, 并且让创建出来的UIView的类型, 继承自你刚刚自定义的那个类. 接下来我们就可以在刚刚自定义的类, - (void)drawRect:(CGRect)rect的方法中愉快的玩耍了. 一般新建一个继承自UIView的类, 在.m中会自动帮我们生成好- (void)drawRect:(CGRect)rect方法, 我们只需要打开就好. 12345678910111213#import "DrawView.h"@implementation DrawView/*// Only override drawRect: if you perform custom drawing.// An empty implementation adversely affects performance during animation.- (void)drawRect:(CGRect)rect &#123; // Drawing code&#125;*/@end 画线画一条直线12345678910111213141516171819- (void)drawRect:(CGRect)rect &#123; // 获取图形上下文(在 drawRect: 方法中, 系统已经帮我们创建好了图形上下文) CGContextRef ctx = UIGraphicsGetCurrentContext(); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPath]; // 设置起点 [path moveToPoint:CGPointMake(50, 100)]; // 添加一条线到某个点 [path addLineToPoint:CGPointMake(200, 200)]; // 添加路径到图形上下文 CGContextAddPath(ctx, path.CGPath); // 绘制 CGContextStrokePath(ctx);&#125; 两点成一线, 所以我们设置起点, 设置终点, 就可以画线 CGContextAddPath(ctx, path.CGPath); 因为这个函数需要接收的参数是CGPathRef, 而我们创建的并不是, 所以我们需要调用UIBezierPath类的- (CGPathRef)CGPath方法, 把 UIBezierPath类型转换成CGPathRef. 画两条直线 想要实现画两条或多条直线的方法, 有两种方式. 第一种 12345678910111213141516171819202122232425- (void)drawRect:(CGRect)rect &#123; // 获取图形上下文(在 drawRect: 方法中, 系统已经帮我们创建好了图形上下文) CGContextRef ctx = UIGraphicsGetCurrentContext(); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPath]; // 设置起点 [path moveToPoint:CGPointMake(50, 100)]; // 设置终点 [path addLineToPoint:CGPointMake(200, 200)]; // 一个路径对象可以包含很多线段, 所以我们可以继续设置起点 [path moveToPoint:CGPointMake(50, 200)]; // 设置终点 [path addLineToPoint:CGPointMake(100, 200)]; // 添加路径到图形上下文 CGContextAddPath(ctx, path.CGPath); // 绘制 CGContextStrokePath(ctx);&#125; 第二种 1234567891011121314151617181920212223242526272829303132- (void)drawRect:(CGRect)rect &#123; // 获取图形上下文(在 drawRect: 方法中, 系统已经帮我们创建好了图形上下文) CGContextRef ctx = UIGraphicsGetCurrentContext(); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPath]; // 设置起点 [path moveToPoint:CGPointMake(200, 100)]; // 设置终点 [path addLineToPoint:CGPointMake(200, 200)]; // 添加路径到图形上下文 CGContextAddPath(ctx, path.CGPath); // 因为上一个路径已经添加到了图形上下文中了, 所以我们可以重新创建一个UIBezierPath对象, // 来改变path的指针指向. path = [UIBezierPath bezierPath]; // 设置起点,移动到某个位置 [path moveToPoint:CGPointMake(30, 200)]; // 设置终点 [path addLineToPoint:CGPointMake(100, 200)]; // 添加路径到图形上下文 CGContextAddPath(ctx, path.CGPath); // 绘制 CGContextStrokePath(ctx);&#125; 对比完两种方法, 第二种方法比第一种方法多了几个步骤, 1.重新创建新的路径 2.设置起点, 终点 3.添加路径到上下文. 从实用角度来讲, 我个人更倾向于第二种, 自己的路径, 自己的路径对象进行管理, 从代码行数角度来讲, 当然是第一种好. 上面所讲的方法是用来绘制平行或无连接关系的线段. 画有 连接关系 的线段和设置线段的属性1234567891011121314151617181920212223242526272829303132- (void)drawRect:(CGRect)rect &#123; // 获取图形上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPath]; // 设置起点 [path moveToPoint:CGPointMake(30, 100)]; // 设置终点 [path addLineToPoint:CGPointMake(200, 200)]; // 设置第二根线的终点 [path addLineToPoint:CGPointMake(100, 100)]; // 添加路径到图形上下文 CGContextAddPath(ctx, path.CGPath); // 设置线宽 CGContextSetLineWidth(ctx, 10); // 设置线条两端的样式为圆角 CGContextSetLineCap(ctx, kCGLineCapRound); // 设置线条连接处的样式为圆角 CGContextSetLineJoin(ctx, kCGLineJoinRound); // 绘制 CGContextStrokePath(ctx);&#125; 如果画的线段是连接在一起的, 可以直接设置第二根线的终点, 不必重现设置起点. 设置线条两端的样式和连接处的样式的参数是枚举, 剩下的样式请自行尝试. UIBezierPath 因为UIBezierPath类里面已经帮我们封装好了很多东西, 所以绘制线段有更快捷的方法. 1234567891011- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:CGPointMake(50, 50)]; [path addLineToPoint:CGPointMake(200, 200)]; [path stroke]; &#125; 总结123456789绘制步骤可以分成四个大的步骤1. 获取当前View的图形上下文2. 创建路径 2.1 设置起点 2.2 设置终点 2.3 ....3. 添加路径到图形上下文4. 绘制 绘制基本图形矩形和正方形正方形123456- (void)drawRect:(CGRect)rect &#123; // 第一个参数表示需要绘制图形的frame, 第二个参数表示半径(可以通过修改这个参数来达到绘制带圆角的图形和绘制圆形) UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 50, 160, 160) cornerRadius:0]; [path stroke];&#125; 圆角矩形123456- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 50, 160, 100) cornerRadius:20]; [path stroke];&#125; 圆型123456- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 50, 150, 150) cornerRadius:75]; [path stroke];&#125; 这里只放置3种样式的代码, 其他样式可以修改参数, 通过这个方法来绘制正方形, 矩形, 圆角正方形, 圆角矩形, 圆形,等… 椭圆1234- (void)drawRect:(CGRect)rect &#123; UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(30, 30, 200, 100)]; [path stroke];&#125; 用以上方法同样也可以绘制圆形 圆弧123456789101112131415- (void)drawRect:(CGRect)rect &#123; // 获取当前控件的圆心 CGPoint center = CGPointMake(rect.size.width * 0.5, rect.size.height * 0.5); // 获取半径 CGFloat radius = rect.size.width * 0.5 * 0.5; /* 参数一 需要绘制圆弧的圆心在哪, 参数二 圆弧到圆心的半径, 参数三 圆弧开始角度, 参数四 圆弧结束角度, 参数五 传入YES表示顺时针, 传入NO表示逆时针 */ UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:0 endAngle:M_PI clockwise:YES]; [path stroke];&#125; 从以上图片可以看出, 开始角度并不是从12点钟方向开始的, 而是从3点钟方向开始的. 所以在绘制圆弧的时候需要注意, 如果需要从12点钟方向开始, 那么开始角度应该是-90度开始 在OC中, 已经定义好了一些常用的宏, M_PI表示180°, M_PI_2表示90°, M_PI_4表示45°.(具体可以跳到头文件进行查看) 具体角度与弧度互转, 引用至百度知道的答案 弧度 ＝ (角度 / 180) PIPI就是“派”比如180度角，转换之后的弧度就是PI，45度的话是四分之一PI。反过来也一样，角度 = 弧度 / PI 180 扇形123456789101112131415161718- (void)drawRect:(CGRect)rect &#123; // 获取圆心 CGPoint center = CGPointMake(rect.size.width * 0.5, rect.size.height * 0.5); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:100 startAngle:0 endAngle:M_PI_2 clockwise:YES]; // 添加一根线到圆心 [path addLineToPoint:center]; // 从圆心添加线到圆弧的起始点 // [path addLineToPoint:CGPointMake(center.x + 100, center.y)]; // 关闭路径 [path closePath]; // 绘制 [path stroke];&#125; 从上述代码可以看出, 绘制扇形, 其实就是先绘制圆弧, 然后添加一根线到圆心, 再添加一根线到圆弧的起始点位置, 就组成了一个扇形. UIBezierPath类为我们提供了更加便捷的方法, 所以在添加第二根线, 圆心到圆弧起始点位置, 我们可以直接调用[path closePath]的对象方法, 这样也减少了位置的计算. 扇形的描边和填充修改描边颜色123456789101112- (void)drawRect:(CGRect)rect &#123; // 此处省略创建路径等代码, 重点讲解如何描边 // 关闭路径 [path closePath]; // 设置描边颜色 [[UIColor greenColor] setStroke]; // 绘制 [path stroke];&#125; 在关闭路径后, 绘制之前, 如果我们需要设置扇形的线条颜色, 可以通过setStroke方法来设置颜色. 填充123456789101112131415- (void)drawRect:(CGRect)rect &#123; // 获取圆心 CGPoint center = CGPointMake(rect.size.width * 0.5, rect.size.height * 0.5); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:100 startAngle:0 endAngle:M_PI_2 clockwise:YES]; // 添加一根线到圆心 [path addLineToPoint:center]; // 设置填充颜色 [[UIColor blueColor] setFill]; // 填充 [path fill];&#125; 如果你是需要填充扇形, 那么可以省略关闭路径这一步骤closePath 并且不再是调用stroke方法, 而是调用fill方法 同时填充和描边 如果你需要同时填充和描边扇形, 那么UIBezierPath并没有帮我们封装类似的方法, 所以我们还是需要使用CoreGraphics框架中的C语言函数来实现. 12345678910111213141516171819202122232425262728293031- (void)drawRect:(CGRect)rect &#123; // 获取圆心 CGPoint center = CGPointMake(rect.size.width * 0.5, rect.size.height * 0.5); // 获取上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 创建路径 UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:100 startAngle:0 endAngle:M_PI_2 clockwise:YES]; // 添加一根线到圆心 [path addLineToPoint:center]; // 关闭路径 [path closePath]; // 把路径添加到上下文 CGContextAddPath(ctx, path.CGPath); // 设置填充颜色 [[UIColor blueColor] setFill]; // 设置描边颜色 [[UIColor greenColor] setStroke]; // 设置线宽 CGContextSetLineWidth(ctx, 5); // 渲染 (第二个形参表示绘画模式是填充和描边都需要, 这个参数是枚举) CGContextDrawPath(ctx, kCGPathFillStroke);&#125; 这里是需要关闭路径的, 不关闭会有问题. 你可以试试注释掉关闭路径的代码.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift导入SQLite库, Swift桥接OC 步骤]]></title>
      <url>%2F2016%2F04%2F14%2FSwift%E5%AF%BC%E5%85%A5SQLite%E5%BA%93%2C%20Swift%E6%A1%A5%E6%8E%A5OC%20%E6%AD%A5%E9%AA%A4%2F</url>
      <content type="text"><![CDATA[注: 图中所用的Xcode版本为Xcode7.3 导入库按下图顺序进行导入SQLite库 桥接文件导入成功后, 新建一个Header File文件进行桥接 如果没有提示, 就按图中头文件名手动敲入 打开Build Settings, 输入bri关键字进行搜索, 找到图中我选中的 Objective-C Bridging Header 这一行, 点击此行右边空白的地方, 弹出输入框, 从左边的文件栏选中文件你的桥接文件拽入输入框, 然后删除前面多余的路径地址 然后编译一下, 成功就表示路径地址设置对了 随便回到哪个控制器, 能够敲出sqlite的方法, 并且编译成功, 就表示导入成功了 注意点:移除sqlite库文件的时候, 千万不要选择移除到废纸篓, 不然不小心清空废纸篓了, 那么你的库文件也被删掉了, 点击图中箭头指示的移除引用即可]]></content>
    </entry>

    
  
  
</search>
